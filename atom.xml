<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ytlm</title>
  <subtitle>stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ytlm.github.io/"/>
  <updated>2017-05-27T06:12:02.879Z</updated>
  <id>https://ytlm.github.io/</id>
  
  <author>
    <name>ytl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tcp建立连接为什么需要三次握手</title>
    <link href="https://ytlm.github.io/2017/05/tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>https://ytlm.github.io/2017/05/tcp建立连接为什么需要三次握手/</id>
    <published>2017-05-03T01:22:40.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>众所周知tcp传输层协议在建立连接的时候需要三次才能建立起一个真正的可靠连接，可是为什么是三次呢，不可以是两次，四次等等呢，可以自己思考一番，带着疑问可以看下文。</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ul>
<li>在《计算机网络》一书中其中有提到，三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。</li>
</ul>
<a id="more"></a>
<ul>
<li><p>问题的本质是，信道是不可靠的，但是我们要建立可靠的连接发送可靠的数据，也就是数据传输是需要可靠的。在这个时候三次握手是一个理论上的最小值，并不是说是tcp协议要求的，而是为了满足在不可靠的信道上传输可靠的数据所要求的。</p>
</li>
<li><p>我们再来考虑，如果不是三次握手会出现什么情况呢：</p>
<blockquote>
<p>假设有A和B两端要进行通信，<br>1, 第一次：首先A发送一个(SYN)到B，意思是A要和B建立连接进行通信；</p>
<blockquote>
<p>如果是只有一次握手的话，这样肯定是不行的，A压根都不知道B是不是收到了这个请求。</p>
</blockquote>
<p>2, 第二次：B收到A要建立连接的请求之后，发送一个确认(SYN+ACK)给A，意思是收到A的消息了，B这里也是通的，表示可以建立连接；</p>
<blockquote>
<p>如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。</p>
</blockquote>
<p>3, 第三次：A如果收到了B的确认消息之后，再发出一个确认(ACK)消息，意思是告诉B，这边是通的，然后A和B就可以建立连接相互通信了；</p>
<blockquote>
<p>这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通信了，已经可以建立一个可靠的连接，并且可以相互发送数据。<br>4, 第四次：这个时候已经不需要B再发送一个确认消息了，两边已经通过前三次建立了一个可靠的连接，如果再发送第四次确认消息的话，就浪费资源了。</p>
<p>如果第二个报文段B发出的(SYN+ACK)分别发送的话，也是可以理解为四次，但是被优化了，一起发送了。</p>
</blockquote>
</blockquote>
</li>
<li><p>超时重传机制，</p>
<blockquote>
<p>(1) 如果第一个包，A发送给B请求建立连接的报文(SYN)如果丢掉了，A会周期性的超时重传，直到B发出确认(SYN+ACK)；<br>(2) 如果第二个包，B发送给A的确认报文(SYN+ACK)如果丢掉了，B会周期性的超时重传，直到A发出确认(ACK)；<br>(3) 如果第三个包，A发送给B的确认报文(ACK)如果丢掉了，</p>
<blockquote>
<ul>
<li>A在发送完确认报文之后，单方面会进入ESTABLISHED的状态，B还是SYN_RCVD状态</li>
<li>如果此时双方都没有数据需要发送，B会周期性的超时发送(SYN+ACK)，直到收到A的确认报文(ACK)，此时B也进入ESTABLISHED状态，双方可以发送数据；</li>
<li>如果A有数据发送，A发送的是(ACK+DATA)，B会在收到这个数据包的时候自动切换到ESTABLISHED状态，并接受数据(DATA)；</li>
<li>如果这个时候B要发送数据，B是发送不了数据的，会周期性的超时重传(SYN+ACK)直到收到A的确认(ACK)B才能发送数据。</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p>三次握手牵扯到的状态转换</p>
<blockquote>
<ul>
<li><strong> LISTEN </strong> 表示socket已经处于listen状态了，可以建立连接；</li>
<li><strong> SYN_SENT </strong> 表示socket在发出connect连接的时候，会首先发送SYN报文，然后等待另一端发送的确认报文(ACK)，表示这端已经发送完SYN报文了；</li>
<li><strong> SYN_RCVD </strong> 表示一端已经接收到SYN报文了；</li>
<li><strong> ESTABLISHED </strong> 表示已经建立连接了，可以发送数据了。</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/616078-5093ce7f19f61840.png!blog?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手状态装换图解"></p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul>
<li>说完TCP建立连接的时候为什么是三次，相对的就会想到为什么断开连接的时候是需要四次呢，而不是三次，五次等等呢；</li>
<li>本质的原因是tcp是全双公的，要实现可靠的连接关闭，A发出结束报文FIN，收到B确认后A知道自己没有数据需要发送了，B知道A不再发送数据了，自己也不会接收数据了，但是此时A还是可以接收数据，B也可以发送数据；当B发出FIN报文的时候此时两边才会真正的断开连接，读写分开。</li>
<li>四次挥手牵扯到的状态装换<blockquote>
<ul>
<li><strong> FIN_WAIT_1 </strong> 表示在等待另一方的FIN报文，和FIN_WAIT_2的区别是，FIN_WAIT_1表示socket现在要主动关闭连接，在发送完FIN报文后socket进入FIN_WAIT_1状态，当收到另一方发送FIN的ACK之后立即进入FIN_WAIT_2状态；</li>
<li><strong> FIN_WAIT_2 </strong> 同上，此时需要做的事情是可能还会接收数据，然后等待另一方的FIN；</li>
<li><strong> TIME_WAIT </strong> 存在主动关闭的一方，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL(Max Segment Lifetime))后即可回到CLOSED可用状态了，需要等一段时间时原因是网络是不可靠的，不能保证这个ACK发送成功了，如果失败了，对端会超时重传FIN；</li>
<li><strong> CLOSING </strong> 表示在发送FIN之后，没有收到对方的ACK，而是收到了对方的FIN，这中情况很少见，只有在两端几乎同时关闭同一个socket的时候才会出现CLOSING状态；</li>
<li><strong> CLOSE_WAIT </strong> 表示收到对方的FIN之后，回给对方ACK，此时处于CLOSE_WAIT状态，等待关闭，要看自己是否还有数据要发送；</li>
<li><strong> LAST_ACK </strong> 表示收到对方的FIN之后，回给对方ACK，然后自己也要关闭发送FIN，等待另一方的ACK时候的状态；</li>
<li><strong> CLOSED </strong> 这个状态表示连接已经断开。</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/616078-5aeaf2475546f960.png!blog?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手状态装换图解"></p>
<ul>
<li>最后放一张状态转换图<br><img src="http://upload-images.jianshu.io/upload_images/616078-ca7ed52491141161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手和四次挥手状态转换图"></li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>在状态转换图中省略了数据的发送；</li>
<li>对于tcp/ip的学习还需要努力，可能文中有些表达不够严谨，还望海涵。</li>
</ul>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;众所周知tcp传输层协议在建立连接的时候需要三次才能建立起一个真正的可靠连接，可是为什么是三次呢，不可以是两次，四次等等呢，可以自己思考一番，带着疑问可以看下文。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;headerlink&quot; title=&quot;三次握手&quot;&gt;&lt;/a&gt;三次握手&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在《计算机网络》一书中其中有提到，三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="网络协议" scheme="https://ytlm.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>安装systemmap生成openresty的火焰图</title>
    <link href="https://ytlm.github.io/2017/04/%E5%AE%89%E8%A3%85systemtap%E7%94%9F%E6%88%90openresty%E7%9A%84%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    <id>https://ytlm.github.io/2017/04/安装systemtap生成openresty的火焰图/</id>
    <published>2017-04-27T10:50:32.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SystemTap"><a href="#SystemTap" class="headerlink" title="SystemTap"></a>SystemTap</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><ul>
<li><a href="https://sourceware.org/systemtap/" target="_blank" rel="external">systemtap</a>是一个诊断linux系统性能和功能问题的开源软件，并且允许开发人员编写和重用简单的脚本深入探查linux系统的活动，可以快速安全的提取过滤总结数据，以便能够诊断复杂的性能或功能问题。</li>
<li>基本思想是name events(命名事件)，并给它们处理程序。每当事件发生的时候，linux内核运行处理程序，就像一个子程序一样，之后恢复。处理程序是一系列的脚本语言，用于指定事件完成时要完成的工作，这种工作通常包括是提取数据，打印结果等。</li>
<li>systemtap通过将脚本装换成C，运行系统的时候创建一个内核模块，当模块加在的时候，它通过挂载到内核的钩子来激活所有的探测事件。最后，这次事件结束的时候，挂载的钩子断开连接，移除模块。</li>
</ul>
<a id="more"></a>
<blockquote>
<p>systemtap工具功能很强大，目前刚接触，在此仅仅通过<a href="https://sourceware.org/systemtap/tutorial/Introduction.html" target="_blank" rel="external">官网</a>做一些简单的介绍。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>环境 centos 7，直接用<code>yum install systemtap systemtap-runtime</code>安装，如果遇到依赖包的问题，安装所需要的依赖就好了；</li>
<li>另外需要注意一个重要的问题是需要安装kernel-debuginfo和kernel-debuginfo-common；可以直接用yum安装也可以<a href="http://debuginfo.centos.org/" target="_blank" rel="external">下载rpm</a>包安装；但是 <strong> 必须要和kernel版本一样 </strong></li>
<li>安装完成后可以用<code>stap -v -e &#39;probe vfs.read {printf(&quot;read performed\n&quot;); exit()}&#39;</code>测试，如果不出意外的话会正常输出的</li>
</ul>
<blockquote>
<p>表示在这里被坑了好久，全部安装好后运行的时候一直报错，累。。。</p>
</blockquote>
<h2 id="Openresty"><a href="#Openresty" class="headerlink" title="Openresty"></a>Openresty</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><a href="http://openresty.org/" target="_blank" rel="external">OpenResty</a>是一个动态的基于nginx和lua的网络平台。把nginx和lua集成在一起，可以通过lua完成一些复杂的需求，而不用再去开发C层面的module了，同时性能也很理想。</li>
</ul>
<blockquote>
<ul>
<li>目前应该直接集成<a href="http://luajit.org/" target="_blank" rel="external">LuaJIT</a>了，简单来说LuaJIT是lua的一个更高性能的版本。</li>
</ul>
</blockquote>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul>
<li>直接到官网下载源码进行编译安装就行了，如果遇到一些依赖，就直接安装依赖就行了。</li>
</ul>
<blockquote>
<p>目前在做nginx的相关工作，所以对openresty了解的比较多一点，如有兴趣，欢迎共同交流。</p>
</blockquote>
<h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="external">火焰图(Flame Graphs)</a>是一个通过可视话堆栈的方法，可以直观的看出每个函数占用cpu的时间，内存，off-cpu等等，对于我们排查软件问题很有帮助。</li>
<li>显示的是，Y轴是堆栈的深度，X轴是样本数量。每个样本（函数）是一个矩形。鼠标点击可以看到一些详细的信息。通过这些可以看出那些需要调整优化。</li>
</ul>
<blockquote>
<p>对于火焰图也是最近才了解到的，有些解释可能很牵强，误怪，后面会慢慢的了解学习的。</p>
</blockquote>
<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><ul>
<li>openresty提供了一套完整的<a href="https://github.com/openresty/openresty-systemtap-toolkit" target="_blank" rel="external">工具</a>用于探测运行的状况。可以直接下载并根据介绍运行。</li>
<li>然后下载<a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="external">FlameGraph</a>火焰图生成工具，用于把前面采样到的信息绘制成火焰图。</li>
<li>然后在浏览器中打开进行观察分析。</li>
</ul>
<blockquote>
<p>在采样信息的时候需要让nginx在压力很大的情况下，这样得出的结果才会有更大的参考性。</p>
</blockquote>
<h3 id="分析火焰图"><a href="#分析火焰图" class="headerlink" title="分析火焰图"></a>分析火焰图</h3><ul>
<li>采样C层面的信息进行分析</li>
</ul>
<blockquote>
<ol>
<li>sudo ./sample-bt -p 15507 -t 60 -u -a ‘-DMAXACTION=100000’ &gt; /tmp/nginx.bt<blockquote>
<p>-p 表示nginx的worker的pid<br>-t 表示采样时间<br>-u 表示在用户空间<br>-a 传递一些参数，因为我自己的机器的原因所以需要传递这个参数，要不然会报错的</p>
</blockquote>
</li>
<li>sudo ./stackcollapse-stap.pl /tmp/nginx.bt &gt; /tmp/nginx.cbt</li>
<li>sudo ./flamegraph.pl /tmp/nginx.cbt &gt; /tmp/nginx.svg</li>
<li>用浏览器打开/tmp/nginx.svg</li>
</ol>
</blockquote>
<p><img src="http://onl0zwdvm.bkt.clouddn.com/nginx.svg" alt="openresty C层面的火焰图"></p>
<blockquote>
<p>我用wrk给nginx的压力还不是很大大概CPU才20%左右，所以这个不是很准确的；但是也可以看出一些问题，比如看出在发送数据的时候还是有问题的，都在body_filter阶段，可能因为我用了很多的buffer的原因</p>
</blockquote>
<ul>
<li>采样lua层面的信息进行分析，在编译luaJIT的时候需要添加<code>CCDEBUG=-g</code>参数</li>
</ul>
<blockquote>
<ol>
<li>sudo ./ngx-sample-lua-bt -a ‘-DMAXACTION=100000’ -p 4790 –luajit20 -t 60 &gt; /tmp/lua.bt<blockquote>
<p>各个参数的意思和上面的一样。</p>
</blockquote>
</li>
<li>sudo ./fix-lua-bt /tmp/lua.bt &gt; /tmp/lua-fix.bt</li>
<li>sudo ./stackcollapse-stap.pl /tmp/lua-fix.bt &gt; /tmp/lua-fix.cbt</li>
<li>sudo ./flamegraph.pl /tmp/lua-fix.cbt &gt; /tmp/lua-fix.svg</li>
<li>浏览器打开/tmp/lua-fix.svg<br>图的话在这里就不再贴出来了</li>
</ol>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>上面用<code>sample-bt</code>生成的是on-cpu的相关数据，也可以用<code>sample-bt-off-cpu</code>生成off-cpu的相关分析数据，具体的区别可以到相关网站进行详细的了解；</li>
<li>首先呢，这个火焰图是一个很好的分析工具，相信可以为我们再排查问题的时候提供很大的帮助，目前我也是刚接触这个工具，还在慢慢摸索学习当中；</li>
<li>另外一个就是在安装遇到过很多的坑，也相当无语，但是都通过google慢慢的一个一个解决了，要有一颗永不放弃的心不是吗；</li>
</ul>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SystemTap&quot;&gt;&lt;a href=&quot;#SystemTap&quot; class=&quot;headerlink&quot; title=&quot;SystemTap&quot;&gt;&lt;/a&gt;SystemTap&lt;/h2&gt;&lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://sourceware.org/systemtap/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;systemtap&lt;/a&gt;是一个诊断linux系统性能和功能问题的开源软件，并且允许开发人员编写和重用简单的脚本深入探查linux系统的活动，可以快速安全的提取过滤总结数据，以便能够诊断复杂的性能或功能问题。&lt;/li&gt;
&lt;li&gt;基本思想是name events(命名事件)，并给它们处理程序。每当事件发生的时候，linux内核运行处理程序，就像一个子程序一样，之后恢复。处理程序是一系列的脚本语言，用于指定事件完成时要完成的工作，这种工作通常包括是提取数据，打印结果等。&lt;/li&gt;
&lt;li&gt;systemtap通过将脚本装换成C，运行系统的时候创建一个内核模块，当模块加在的时候，它通过挂载到内核的钩子来激活所有的探测事件。最后，这次事件结束的时候，挂载的钩子断开连接，移除模块。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="nginx" scheme="https://ytlm.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://ytlm.github.io/tags/nginx/"/>
    
      <category term="openresty" scheme="https://ytlm.github.io/tags/openresty/"/>
    
      <category term="systemmap" scheme="https://ytlm.github.io/tags/systemmap/"/>
    
      <category term="linux" scheme="https://ytlm.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>关于nginx缓存配置指令用法详解</title>
    <link href="https://ytlm.github.io/2017/04/%E5%85%B3%E4%BA%8Enginx%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ytlm.github.io/2017/04/关于nginx缓存配置指令用法详解/</id>
    <published>2017-04-18T02:53:11.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx简介"><a href="#nginx简介" class="headerlink" title="nginx简介"></a>nginx简介</h2><p>众所周知nginx近些年在服务器领域占据着很重要的作用，目前我主要接触的关于nginx是作为代理服务器来用的，至于再详细的，有兴趣的可以查阅相关文档<a href="http://nginx.org/" target="_blank" rel="external">nginx</a>，就不在这里赘述。本文主要讲述的是把nginx配置成一个缓存服务器组件来用，尽可能详细的把nginx关于缓存的指令解释清楚。</p>
<a id="more"></a>
<h2 id="配置指令详解"><a href="#配置指令详解" class="headerlink" title="配置指令详解"></a>配置指令详解</h2><ul>
<li><strong><em> proxy_buffering </em></strong> on | off</li>
</ul>
<blockquote>
<ul>
<li>控制着缓存的总开关，如果设置off缓存就不会生效；设置on缓存相关的配置才会生效；</li>
<li>缓存的开关也可以通过设置”X-Accel-Bufferinf”这个header为”yes” | “no”来控制；</li>
<li>“X-Accel-Buffering”这个header可以被proxy_ingore_headers指令忽略；</li>
<li><strong><em> proxy_cache </em></strong>  <em>zone</em> | off</li>
<li>定义一个共享内存用于缓存，其中主要存一些缓存文件的主要信息，用于检索；</li>
<li>同一个共享内存可以被用于不同的地方，<em> zone </em>可以支持配置变量；</li>
<li>off 的意思是禁用从上层继承的缓存配置；</li>
</ul>
</blockquote>
<ul>
<li><strong><em> proxy_cache_background_update </em></strong>  on | off</li>
</ul>
<blockquote>
<ul>
<li>允许在后台发送子请求来更新过期的缓存文件；</li>
<li>这个一般都不常用，一般一个请求过来判断一下缓存时间，如果 过期了再从后端取就行了；</li>
</ul>
</blockquote>
<ul>
<li><strong><em> proxy_cache_bypass </em></strong>  string …</li>
</ul>
<blockquote>
<p>如果配置的字符串传中有一个不为空并且不等于”0”，这时候这个请求的相应就不会从缓存中取，应该到后端去取数据；</p>
</blockquote>
<ul>
<li><strong><em> proxy_no_cache </em></strong> string …</li>
</ul>
<blockquote>
<p>如果响应的数据中有任何一个满足让字符串中的值至少有一个不为空并且不等于”0”，那么这个响应就不会被缓存下来；</p>
</blockquote>
<ul>
<li><strong><em> proxy_cache_key </em></strong> string</li>
</ul>
<blockquote>
<ul>
<li>配置缓存的key，缓存相关的内容都是根据这个key来进行查找的；</li>
<li>key的配置很有灵活性，不同的配置可以达到不同的效果；</li>
</ul>
</blockquote>
<ul>
<li><strong><em> proxy_cache_lock </em></strong> on | off</li>
</ul>
<blockquote>
<p>设置为on的时候，表示在同一时间如果请求同一个cache key的多个请求在没有缓存的情况下只有一个请求会通过后端取数据，其它的请求直接取上个请求的缓存，或者等到超时，直接也去后端去取数据；</p>
</blockquote>
<ul>
<li><strong><em> proxy_cache_lock_timeout </em></strong> time</li>
</ul>
<blockquote>
<ul>
<li>这个超时时间就是上面的超时时间，如果proxy_cache_lock打开的时候，同一时间同一资源只有一个请求会到后端取数据，其它的请求如果达到这个超时时间之后也会直接到后端取数据；</li>
<li>过了超时时间之后去到后端取下来数据不会缓存下来；</li>
</ul>
</blockquote>
<ul>
<li><strong><em> proxy_cache_lock_age </em></strong> time</li>
</ul>
<blockquote>
<ul>
<li>这个的意思是在time时间内一个请求还没有将数据完全从后端取下来并且缓存，那么下一个请求就会被发送到后端，并且这时候也要把数据缓存下来；</li>
<li>这个lock age和上个lock timeout一直没有搞清楚根本的区别，这里只是简单的解释一下，我好像用的也不多，如果谁能够解释一下还望不吝赐教，谢谢0.0；</li>
</ul>
</blockquote>
<ul>
<li><em>*</em> proxy_cache_methods GET | HEAD | POST …</li>
</ul>
<blockquote>
<p>如果客户端请求的方法在这个配置的方法列表中，这个请求才有可能被缓存，缓存还受其它的条件制约；</p>
</blockquote>
<ul>
<li><strong><em> proxy_cache_path </em></strong> path [一堆的可选参数]</li>
</ul>
<blockquote>
<ul>
<li>proxy_cache_path /data/nginx/cachet levels=1:2 use_temp_path=off keys_zone=data:60m inactive=365d max_size=10m；</li>
<li>上面是一个典型的配置，下面来解释一下每个的含义 ：<blockquote>
<ul>
<li>/data/nginx/cachet : 这个表示缓存文件实际的存储路径；</li>
<li>levels=1:2 : 这个表示缓存文件的分级存储，如果不这样设置的话所有的文件都在同一个文件夹下面，看着比较乱，如果配成这样，缓存文件在实际上大概像这样 <strong><em> /data/nginx/cache/c/29/b7f54b2df7773722d382f4809d65029c </em></strong>；</li>
<li>ues_temp_path=off : 禁用缓存响应到临时目录，直接缓存到缓存目录；</li>
<li>keys_zone=data:60m : 设置一个共享内存和大小，里面存储的是缓存文件的一些key信息，在测试的时候发现1m的共享内存大概能够存8k左右个key；</li>
<li>inactive=365d : 设置缓存时间，这个也受其它的条件限制，比如说响应头有Cache-Control: max-age=10，这样只能缓存10s；</li>
<li>max_size=10m; 设置这个缓存目录的总大小，大小要根据配置的共享内存进行合理的配置；如果超过这个大小会通过LRU算法进行淘汰；</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li><strong><em> proxy_cache_valid </em></strong> [code … ] time</li>
</ul>
<blockquote>
<p>设置特定的响应状态码缓存特定的时间；</p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>上面就是我平常用到的关于nginx缓存的配置，组合起来还是能够达到很多需求的；</li>
<li>这里只是介绍我平常接触到很多的指令，还可能有一些我没有接触过的关于缓存的配置指令，欢迎补充；</li>
<li>另外在配置缓存目录的时候通过proxy_cache_path和proxy_cahce配置多个来达到把不同的缓存存储到不同的目录，这个时候就涉及到负载均衡了，要不然不同的目录缓存的大小不一样；</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="external">http://nginx.org/en/docs/http/ngx_http_proxy_module.html</a></p>
</blockquote>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nginx简介&quot;&gt;&lt;a href=&quot;#nginx简介&quot; class=&quot;headerlink&quot; title=&quot;nginx简介&quot;&gt;&lt;/a&gt;nginx简介&lt;/h2&gt;&lt;p&gt;众所周知nginx近些年在服务器领域占据着很重要的作用，目前我主要接触的关于nginx是作为代理服务器来用的，至于再详细的，有兴趣的可以查阅相关文档&lt;a href=&quot;http://nginx.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nginx&lt;/a&gt;，就不在这里赘述。本文主要讲述的是把nginx配置成一个缓存服务器组件来用，尽可能详细的把nginx关于缓存的指令解释清楚。&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="https://ytlm.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://ytlm.github.io/tags/nginx/"/>
    
      <category term="cache" scheme="https://ytlm.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>ISO的OSI七层网络协议模型</title>
    <link href="https://ytlm.github.io/2017/04/ISO%E7%9A%84OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ytlm.github.io/2017/04/ISO的OSI七层网络协议模型/</id>
    <published>2017-04-10T01:01:17.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>在网络的大环境中扮演者重要的角色的是网络协议，在这里简单的介绍一下关于ISO七层网络协议模型，当然还有TCP/IP四层网络协议，这里不再赘述。<br><a id="more"></a></p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在互联网中有千千万万的主机，也有千千万万应用程序，如果不同的主机不同的应用程序不遵守一个规则，就没法交流，那么也就不能称之为互联网了，这时候网络协议的重要性就体现出来了，我们都遵循同样的协议，这样主机和应用程序之间的交流就没有问题了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在网络协议实现的过程中将不同的功能抽象出来，单独实现，只需要提供接口为其它的功能提供服务，具体实现是对其它的服务透明的；这样的好处是每一个服务实现起来只完成特定的功能，实现起来简单；另外在维护的过程中如果出错也更容易定位并发现问题，所以ISO在定制网络协议的时候定义了OSI(Open System Interconnection)协议模型，该模型共分七层，从下至上一次是: 1,物理层; 2,数据链路层; 3,网络层; 4,传输层; 5,会话层; 6,表示层; 7,应用层。下面简单的介绍每层完成的功能。</p>
<h3 id="1，物理层-Physical-Layer"><a href="#1，物理层-Physical-Layer" class="headerlink" title="1，物理层(Physical Layer)"></a>1，物理层(Physical Layer)</h3><p>为数据链路层提供了一个数据传输的物理媒体，在其上传送比特流，该层数据的单位是比特(bit)。另外该层规定了激活，维持，关闭通信端点之间的机械特性，电气特性，功能特性以及过程特性。</p>
<h3 id="2，数据链路层-Data-Link-Layer"><a href="#2，数据链路层-Data-Link-Layer" class="headerlink" title="2，数据链路层(Data Link Layer)"></a>2，数据链路层(Data Link Layer)</h3><p>该层在不可靠的物理介质上提供可靠的传输，负责在网络节点之间的线路上通过检测，流量控制和重发等手段，无差错的传送数据，该层数据的单位是帧(frame)，所以每一帧数据必须同时带有同步，地址，差错控制以及流量控制等控制信息；总结起来是: 物理寻址，数据成帧，流量控制，数据检错，重发等。</p>
<h3 id="3，网络层-Network-Layer"><a href="#3，网络层-Network-Layer" class="headerlink" title="3，网络层(Network Layer)"></a>3，网络层(Network Layer)</h3><p>为了将数据从源端系统发送到目的端系统，网络层的主要任务是完成网络寻址，对子网间的数据包进行路由选择，使得分组数据包，该层数据的单位是数据包(packet)， 能够准确无误的按照地址找到目的地，并将数据交付给上层协议；另外还可以实现拥塞控制，网际互连等功能。</p>
<h3 id="4，传输层-Transport-Layer"><a href="#4，传输层-Transport-Layer" class="headerlink" title="4，传输层(Transport Layer)"></a>4，传输层(Transport Layer)</h3><p>该层是端到端的一个层次，主要负责将上层数据分段并提供端到端的，可靠的或不可靠的传输，传输的单位是报文(segment)，该层是网络协议分层中最关键的一层，还要处理端到端的差错控制和流量控制问题。</p>
<h3 id="5，会话层-Session-Layer"><a href="#5，会话层-Session-Layer" class="headerlink" title="5，会话层(Session Layer)"></a>5，会话层(Session Layer)</h3><p>该层主要对传输的报文提供同步管理的服务，在两个不同的主机的互相通信的应用进程之间进行会话的管理，例如确定是半双工还是全双工等；此外还利用在数据中添加校验点来实现数据的同步。</p>
<h3 id="6，表示层-Presentation-Layer"><a href="#6，表示层-Presentation-Layer" class="headerlink" title="6，表示层(Presentation Layer)"></a>6，表示层(Presentation Layer)</h3><p>该层主要的作用是把数据进行转换，保证一个主机的应用程序数据可以被另一个主机的一个应用程序所理解，即把不同计算机中内部的不同表示形式转换成网络通信协议中的标准形式。主要包括数据的加密(解密)，压缩(还原)，格式转换等。</p>
<h3 id="7，应用层-Application-Layer"><a href="#7，应用层-Application-Layer" class="headerlink" title="7，应用层(Application Layer)"></a>7，应用层(Application Layer)</h3><p>该层直接面向用户，主要任务是为操作系统和用户之间提供应用接口。</p>
<h2 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h2><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><ul>
<li>在OSI参考模型中，当一台主机需要传送数据(DATA)时，数据首先通过应用层的接口进入应用层，在应用层数据被加上应用层报头(Application Header, AH)，形成应用层协议数据单元(Protocol Data Unit, PDU)，然后提交到下一层，表示层；</li>
<li>表示层并不关心上层(应用层)的数据格式，而是把整个应用层提交的过来的数据进行整体的封装，添加报文头部(Presentation Header, PH)，然后提交到下一层，会话层；</li>
<li>同样的，会话层，传输层，网络层，数据链路层都分别把上层提交过来的数据加上自己的报头，分别是: 会话层报头(Session Header, SH)，传输层报头(Transport Header, TH), 网络层报头(Network Header, NH),数据链路层报头(Data link Header, DH), 然后提交到下一层。<blockquote>
<p>其中数据链路层还会加上数据链路层报尾(Data link Termination, DT)最终形成一帧数据，在物理层上进行传送。</p>
</blockquote>
</li>
</ul>
<h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><ul>
<li>当一帧数据通过物理层传送到目标主机的物理层上时，该主机的物理层把它递交给上层, 数据链路层。数据链路层负责去掉数据的帧头部(DH)和尾部(DT), 同时进行数据校验，如果需要的话会发送反馈给源端主机，如果校验没有出错，则递交到上层，网络层。</li>
<li>同样的，网络层，传输层，会话层，表示层，应用层也要做相应的动作，并执行对应层的功能，最终原始数据递交到目标主机的具体的应用程序中。</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当然对于不同的设备，它工作在不同的协议层面上，比如路由器是工作在网络层，交换机是工作在数据链路层，集线器是工作在物理层等等。同时在数据的传输过程中不像这里说的那么简单，这里只是简答的介绍，实际上远比这里介绍的复杂，有兴趣的可以查阅相关资料进行详细的了解，相信会有很大的收获的。</p>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络的大环境中扮演者重要的角色的是网络协议，在这里简单的介绍一下关于ISO七层网络协议模型，当然还有TCP/IP四层网络协议，这里不再赘述。&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="网络协议" scheme="https://ytlm.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>nginx基于tcp的转发,适用于HTTPS</title>
    <link href="https://ytlm.github.io/2017/04/nginx%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E8%BD%AC%E5%8F%91-%E9%80%82%E7%94%A8%E4%BA%8EHTTPS/"/>
    <id>https://ytlm.github.io/2017/04/nginx基于tcp的转发-适用于HTTPS/</id>
    <published>2017-04-05T01:52:22.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx的主要功能"><a href="#nginx的主要功能" class="headerlink" title="nginx的主要功能"></a>nginx的主要功能</h2><p>1，正向代理<br>2，反向代理<br>3，负载均衡<br>4，WEB服务器</p>
<blockquote>
<p>通常用nginx主要做反向代理，负载均衡配合反向代理可以做到很多事情；<br>nginx做WEB服务器可以实现动静文件分离；<br>nginx有很多可选的模块，可以对nginx的功能进行扩展；<br>openresty是一个基于nginx与lua的高性能平台，用lua进行扩展；</p>
</blockquote>
<a id="more"></a>
<h2 id="ssl简单介绍"><a href="#ssl简单介绍" class="headerlink" title="ssl简单介绍"></a>ssl简单介绍</h2><p>1，主要的作用是为了互联网安全；<br>2，SSL是介于HTTP和TCP之间的一个可选层，对于TCP/IP协议来说；<br>3，SSL与TLS之间的关系是TLS(Transport Layer Security)继承并增强了SSL(Secure Socket Layer)协议；</p>
<blockquote>
<p>具体的协议交互过程就不再这里展开了，详见参考连接；<br>这里主要说下客户端在SSL协商初期发送的Client Hello请求，其中有个扩展选项，里面有个server name这个可用于转发。</p>
</blockquote>
<h2 id="配置nginx转发tcp"><a href="#配置nginx转发tcp" class="headerlink" title="配置nginx转发tcp"></a>配置nginx转发tcp</h2><p>1，版本，nginx version: nginx/1.11.12；我测试用的是这个版本。<br>2，编译，配置<code>./configure  --with-stream  --with-stream_ssl_preread_module --with-stream_ssl_module</code>最主要的使用这几个模块，有需要可以添加其它的模块；然后编译安装make &amp;&amp; make install。<br>3，配置，具体配置命令参考<a href="https://nginx.org/en/docs/stream/ngx_stream_ssl_preread_module.html" target="_blank" rel="external">pread module</a>和<a href="https://nginx.org/en/docs/stream/ngx_stream_core_module.html" target="_blank" rel="external">stream module</a>，启动的时候指定下面的配置文件</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">user</span>  root;</div><div class="line"><span class="attribute">worker_processes</span>  auto;</div><div class="line"><span class="attribute">error_log</span>  logs/error.log;</div><div class="line"><span class="attribute">pid</span>        logs/nginx.pid;</div><div class="line"><span class="attribute">worker_rlimit_core</span>   <span class="number">2G</span>;</div><div class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</div><div class="line"><span class="section">events</span> &#123;</div><div class="line">    <span class="attribute">worker_connections</span>  <span class="number">81920</span>;</div><div class="line">&#125;</div><div class="line"><span class="section">stream</span> &#123;</div><div class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - [<span class="variable">$time_local</span>] <span class="variable">$connection</span> '</span></div><div class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$proxy_protocol_addr</span> <span class="variable">$server_addr</span> '</span>;</div><div class="line">    <span class="attribute">access_log</span>  logs/access.log  main;</div><div class="line">    <span class="attribute">resolver</span> <span class="number">114.114.114.114</span>;</div><div class="line">    <span class="attribute">resolver_timeout</span> <span class="number">60s</span>;</div><div class="line">    <span class="attribute">variables_hash_bucket_size</span> <span class="number">512</span>;</div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span>       <span class="number">443</span>;</div><div class="line">        <span class="attribute">ssl_preread</span> <span class="literal">on</span>;</div><div class="line">        <span class="attribute">proxy_pass</span> <span class="variable">$ssl_preread_server_name</span>:<span class="number">443</span>;</div><div class="line">        <span class="comment">#大致看了一下源码，这里为什么需要配置端口也没有研究明白，求解释？</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4，目前测试基本上都是可以的，在日志中会有一些错误，不会影响正常服务，还再研究中。</p>
<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><blockquote>
<p><a href="https://nginx.org/en/docs/" target="_blank" rel="external">https://nginx.org/en/docs/</a><br><a href="https://github.com/openresty/lua-nginx-module" target="_blank" rel="external">https://github.com/openresty/lua-nginx-module</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br><a href="http://www.wosign.com/faq/faq2016-0309-04.htm" target="_blank" rel="external">http://www.wosign.com/faq/faq2016-0309-04.htm</a><br><a href="https://segmentfault.com/a/1190000002554673" target="_blank" rel="external">https://segmentfault.com/a/1190000002554673</a></p>
</blockquote>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nginx的主要功能&quot;&gt;&lt;a href=&quot;#nginx的主要功能&quot; class=&quot;headerlink&quot; title=&quot;nginx的主要功能&quot;&gt;&lt;/a&gt;nginx的主要功能&lt;/h2&gt;&lt;p&gt;1，正向代理&lt;br&gt;2，反向代理&lt;br&gt;3，负载均衡&lt;br&gt;4，WEB服务器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通常用nginx主要做反向代理，负载均衡配合反向代理可以做到很多事情；&lt;br&gt;nginx做WEB服务器可以实现动静文件分离；&lt;br&gt;nginx有很多可选的模块，可以对nginx的功能进行扩展；&lt;br&gt;openresty是一个基于nginx与lua的高性能平台，用lua进行扩展；&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="nginx" scheme="https://ytlm.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://ytlm.github.io/tags/nginx/"/>
    
      <category term="https" scheme="https://ytlm.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>hexo travis github</title>
    <link href="https://ytlm.github.io/2017/03/hexo-travis-github/"/>
    <id>https://ytlm.github.io/2017/03/hexo-travis-github/</id>
    <published>2017-03-25T14:16:48.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>利用hexo, travis, github联合的方式进行博客的创建并且自动发布.</p>
<p>1,首先是在github创建对应的github pages, 网上有很多教程,这里就不再赘述.<br>2,安装hexo环境用于生成静态博客,这里简单的列举下自己遇到的坑:</p>
<blockquote>
<p>(1). yml格式的配置冒号(:)后必须要有一个空格.<br>(2). hexo generate不生效的时候要用hexo clean清空缓存.<br>(3). hexo deploy失败的时候注意git公私钥的配置和_config.yml中deploy的配置.<br>(4). 选择hexo的主题next,对于next主题的配置可以根据官网说经进行合理的配置.</p>
</blockquote>
<p>3,travis的使用</p>
<blockquote>
<p>(1). 在(yourself).github.io的git上建立一个hexo分支,<br>       master分支用于页面的显示,<br>       hexo分支用于hexo生成博客和配置,便于同步.<br>(2). travis ci的登陆通过github帐号登陆,然后开启(yourself).github.io的travis;<br>       然后在hexo的分支上创建并提交.travis.yml文件,注意github token的生成和使用<br>(3). 最后就是在hexo的分支上进行写博客和提交到hexo分支上,剩下的发布到master上通过travis自动发布.</p>
</blockquote>
<a id="more"></a>
<p><a href="http://lotabout.me/2016/Hexo-Auto-Deploy-to-Github/" target="_blank" rel="external">参考这里</a><br><a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="external">还有这里</a></p>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用hexo, travis, github联合的方式进行博客的创建并且自动发布.&lt;/p&gt;
&lt;p&gt;1,首先是在github创建对应的github pages, 网上有很多教程,这里就不再赘述.&lt;br&gt;2,安装hexo环境用于生成静态博客,这里简单的列举下自己遇到的坑:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(1). yml格式的配置冒号(:)后必须要有一个空格.&lt;br&gt;(2). hexo generate不生效的时候要用hexo clean清空缓存.&lt;br&gt;(3). hexo deploy失败的时候注意git公私钥的配置和_config.yml中deploy的配置.&lt;br&gt;(4). 选择hexo的主题next,对于next主题的配置可以根据官网说经进行合理的配置.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3,travis的使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(1). 在(yourself).github.io的git上建立一个hexo分支,&lt;br&gt;       master分支用于页面的显示,&lt;br&gt;       hexo分支用于hexo生成博客和配置,便于同步.&lt;br&gt;(2). travis ci的登陆通过github帐号登陆,然后开启(yourself).github.io的travis;&lt;br&gt;       然后在hexo的分支上创建并提交.travis.yml文件,注意github token的生成和使用&lt;br&gt;(3). 最后就是在hexo的分支上进行写博客和提交到hexo分支上,剩下的发布到master上通过travis自动发布.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="总结" scheme="https://ytlm.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="github" scheme="https://ytlm.github.io/tags/github/"/>
    
      <category term="hexo" scheme="https://ytlm.github.io/tags/hexo/"/>
    
      <category term="travis" scheme="https://ytlm.github.io/tags/travis/"/>
    
  </entry>
  
  <entry>
    <title>Wamp更改web根目录</title>
    <link href="https://ytlm.github.io/2016/07/Wamp%E6%9B%B4%E6%94%B9web%E6%A0%B9%E7%9B%AE%E5%BD%95/"/>
    <id>https://ytlm.github.io/2016/07/Wamp更改web根目录/</id>
    <published>2016-07-24T07:44:08.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/xia777xia/article/details/6282346" target="_blank" rel="external">原文链接</a><br>Wampserver安装好后，“www目录”默认为X:/wamp/www，（这里的X是盘符）也就是wampserver安装目录下的www文件夹。实际使用中，默认设置往往不是我们想要的，可能改成其他文件夹更适合我们。</p>
<p>比如e:/xx 或者 d:/php等等。</p>
<p>下面以原来的默认目录为d:/wamp/www改为e:/xx为例。</p>
<a id="more"></a>
<p>1,</p>
<blockquote>
<p>打开wamp/scripts/config.inc.php<br>第47行，$wwwDir = $c_installDir.’/www’;<br>修改为：$wwwDir = ‘e:/xx’;即可。<br>但这时新问题来了，Apache默认根目录还没改过来！继续看第2步！</p>
</blockquote>
<p>2,</p>
<blockquote>
<p>修改Apache默认根目录<br>打开wamp/bin/apache/apache2.2.11/conf/httpd.conf,修改DocumentRoot后面双引号中的值为你所要的。<br>比如将DocumentRoot “D:/wamp/www/”<br>改成DocumentRoot “e:/xx/”<br>同时将<directory “d:="" wamp="" www="" “=""><br>改成<directory “e:="" xx="" “=""></directory></directory></p>
</blockquote>
<p>3,</p>
<blockquote>
<p>重启wampserver即可生效。</p>
</blockquote>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/xia777xia/article/details/6282346&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;Wampserver安装好后，“www目录”默认为X:/wamp/www，（这里的X是盘符）也就是wampserver安装目录下的www文件夹。实际使用中，默认设置往往不是我们想要的，可能改成其他文件夹更适合我们。&lt;/p&gt;
&lt;p&gt;比如e:/xx 或者 d:/php等等。&lt;/p&gt;
&lt;p&gt;下面以原来的默认目录为d:/wamp/www改为e:/xx为例。&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="https://ytlm.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Wamp" scheme="https://ytlm.github.io/tags/Wamp/"/>
    
  </entry>
  
  <entry>
    <title>WampServer-localhost-图标不显示解决办法</title>
    <link href="https://ytlm.github.io/2016/07/Wamp-localhost-%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://ytlm.github.io/2016/07/Wamp-localhost-图标不显示解决办法/</id>
    <published>2016-07-24T07:28:29.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>在用WampServer学习PHP的时候碰到，打开localhost的时候文件图标不显示，解决办法如下</p>
<a id="more"></a>
<p><a href="http://blog.warmcolor.net/2011/11/03/wampserver-localhost-%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" title="原文链接" target="_blank" rel="external">原文链接</a></p>
<p>1，在安装目录中找到<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\wamp\bin\apache\Apache2.2.17\conf\extra\httpd-autoindex.conf</div></pre></td></tr></table></figure></p>
<p>2，打开进行修改,将以下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Alias /icons/ “C:/Dev/Projets/WampServer2-64b/install_files_wampserver2/bin/apache/Apache2.2.17/icons/”</div><div class="line"><span class="tag">&lt;<span class="name">Directory</span> “<span class="attr">C:</span>/<span class="attr">Dev</span>/<span class="attr">Projets</span>/<span class="attr">WampServer2-</span> <span class="attr">64b</span>/<span class="attr">install_files_wampserver2</span>/<span class="attr">bin</span>/<span class="attr">apache</span>/<span class="attr">Apache2.2.17</span>/<span class="attr">icons</span>”\&gt;</span></div><div class="line">	Options Indexes MultiViews</div><div class="line">	AllowOverride None</div><div class="line">	Order allow,deny</div><div class="line">	Allow from all</div><div class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Alias /icons/ “icons/”</div><div class="line"><span class="tag">&lt;<span class="name">Directory</span> “<span class="attr">icons</span>”\&gt;</span></div><div class="line">	Options Indexes MultiViews</div><div class="line">	AllowOverride None</div><div class="line">	Order allow,deny</div><div class="line">	Allow from all</div><div class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>3，上面用的相对目录,</p>
<blockquote>
<p>因为在 httpd.conf 里面设置了<br><code>ServerRoot “D:/wamp/bin/apache/apache2.2.17”</code><br>或者用绝对目录也行.<br><code>\wamp\bin\apache\Apache2.2.17\icons</code></p>
</blockquote>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用WampServer学习PHP的时候碰到，打开localhost的时候文件图标不显示，解决办法如下&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="https://ytlm.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Wamp" scheme="https://ytlm.github.io/tags/Wamp/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 各层的作用</title>
    <link href="https://ytlm.github.io/2016/07/TCP-IP-%E5%90%84%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://ytlm.github.io/2016/07/TCP-IP-各层的作用/</id>
    <published>2016-07-24T07:21:53.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络中的TCP/IP协议学习，纪录每层的作用</p>
<a id="more"></a>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><blockquote>
<p>1，负责接收IP数据报添加头部和尾部然后通过网络发送，或者从网络上接收物理数据帧，抽出ip数据报交给IP层。传输有地址的帧以及错误检测。<br>2，流量控制，有基于反馈的流控制盒基于速率的流控制。<br>3，错误检测和纠正</p>
</blockquote>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><blockquote>
<p>1，负责相邻计算机之间的通信。<br>2，处理来自传输层分组发送的请求；然后对数据进行分组装入IP数据报，并填充包头，之后选择合适的路径然后发送。<br>3，处理输入数据报；检查合法性，然后寻址发送。<br>4，处理路径，流控，拥塞等问题。</p>
</blockquote>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><blockquote>
<p>1，负责点到点的传输。<br>2，格式化信息流。<br>3，提供可靠传输。规定接收端必须发挥确认，如果分组丢失必须重传。</p>
</blockquote>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><blockquote>
<p>1，提供端到端的传输。<br>2，向用户提供一些常用的应用程序，如email,ftp,telnet,smtp,pop3,dns等等</p>
</blockquote>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机网络中的TCP/IP协议学习，纪录每层的作用&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="网络协议" scheme="https://ytlm.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 使用总结</title>
    <link href="https://ytlm.github.io/2016/07/MySQL-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://ytlm.github.io/2016/07/MySQL-使用总结/</id>
    <published>2016-07-24T07:14:56.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>下面是在学习MySQL的时候一些命令的纪录</p>
<a id="more"></a>
<p>1，增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">INSERT INTO &quot;tableName(列1,列2,...)&quot; VALUES(值1,值2,...)</div><div class="line">/* 1,列和值需要意义对应。</div><div class="line">   2，列可以省略，省略时值应该和数据表中的值顺序保持一致。</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>2，删<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DELETE FROM &quot;tableName&quot; WHERE &quot;condition1&quot; AND &quot;condition2&quot; ...</div><div class="line">/* 在执行删除语句的时候一定要写好where后面的条件。 */</div></pre></td></tr></table></figure></p>
<p>3，改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UPDATE &quot;tableName&quot; SET &quot;key = value&quot; WHERE &quot;condition1&quot; AND &quot;condition2&quot; ...</div><div class="line">/* 根据where后面的条件，对表中某些字段数据进行修改。*/</div></pre></td></tr></table></figure></p>
<p>4，查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT &quot;fields&quot; FROM &quot;tableName&quot; WHERE &quot;condition&quot;</div><div class="line">/* 单表查询，根据条件查询某张表中的某几列数据。where和列(fields)可以省略。 */</div><div class="line"></div><div class="line">SELECT &quot;fields&quot; FROM &quot;table1, table2,...&quot; WHERE &quot;condition1&quot; AND &quot;condition2&quot; ...</div><div class="line">/* 多表查询，根据表与表之间的关联关系查询所需要的数据。*/</div></pre></td></tr></table></figure></p>
<p>5，数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CREATE DATABASE &quot;databaseName&quot; /* 创建数据库 */</div><div class="line"></div><div class="line">DROP DATABASE &quot;databaseName&quot; /* 删除数据库 */</div></pre></td></tr></table></figure></p>
<p>6，数据表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name (columnName columnType) /* 创建数据表，column_type为列类型及属性 */</div><div class="line"></div><div class="line">DROP TABLE &quot;tableName&quot; /* 删除数据表 */</div><div class="line"></div><div class="line">ALTER TABLE &quot;tableName&quot; RENAME TO &quot;newTableName&quot;  /* 修改表名称*/</div></pre></td></tr></table></figure></p>
<p>7，ALTER<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE &quot;tableName&quot; DROP &quot;columnName&quot; /*删除表中的某个字段 */</div><div class="line"></div><div class="line">ALTER TABLE &quot;tableName&quot; ADD &quot;columnName columnType&quot; FIRST/[AFTER &quot;columnName&quot;]</div><div class="line">/*在数据表中第一位或者在某个字段之后添加某个字段 */</div><div class="line"></div><div class="line">ALTER TABLE &quot;tableName&quot; MODIFY &quot;columnName&quot; &quot;newColumnType&quot; /* 修改表中某个字段的类型属性 */</div><div class="line"></div><div class="line">ALTER TABLE &quot;tableName&quot; CHANGE &quot;columnName&quot; &quot;columnName newColumnType&quot;</div><div class="line">/* 修改表中的的某个字段名并添加可以添加新的类型，还可以值修改字段类型 */</div><div class="line"></div><div class="line">ALTER TABLE &quot;tableName&quot; RENAME TO &quot;newTableName&quot;  /* 修改表名称*/</div></pre></td></tr></table></figure></p>
<p>8，权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GRANT &quot;power&quot; ON &quot;databaseName&quot; TO &quot;user&quot; /* 给用户user添加数据库databaseName对应的权限power*/</div><div class="line">REVOKE &quot;power&quot; ON &quot;databaseName&quot; FROM &quot;user&quot; /* 移除用户user在数据库databaseName上的权限power */</div><div class="line">FLUSH PRIVILEGES /* 在不重启MySQL服务的情况下使得权限操作生效 */</div></pre></td></tr></table></figure></p>
<p>9, 显示表详细结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SHOW TABLES; 显示所有的表</div><div class="line"></div><div class="line">DESCRIBE table_name; 显示表结构下的所有字段信息 相当于SHOW FIELDS FROM table_name</div><div class="line"></div><div class="line">SHOW FULL FIELDS FROM table_name 显示表结构下的所有字段信息 包含注释</div></pre></td></tr></table></figure></p>
<p>10，其他<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GROUP BY &quot;columnName&quot; /* 对某一列查询结果进行分组统计 */</div><div class="line">ORDER BY &quot;columnName&quot;  ASC/DESC /* 对某一列查询结果进行排序操作，升序ASC，降序DESC */</div><div class="line">SUM(&quot;columnName&quot;) /* 对某一分组进行统计 */</div><div class="line">COUNT(&quot;columnName&quot;) /* 对某一分组进行计数 */</div><div class="line">AVG(&quot;columnName&quot;) /* 对某一分组进行求平均值操作 */</div><div class="line">.......................等等函数</div></pre></td></tr></table></figure></p>
<p><strong><em>后续在学习中会继续进行补充，谢谢！</em></strong></p>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是在学习MySQL的时候一些命令的纪录&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://ytlm.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>javascript 显示当前系统时间</title>
    <link href="https://ytlm.github.io/2016/07/javascript-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    <id>https://ytlm.github.io/2016/07/javascript-显示当前系统时间/</id>
    <published>2016-07-24T07:00:15.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>学习js时候的一些简单的纪录，用js实现显示当前系统时间</p>
<blockquote>
<p>详细代码如下</p>
</blockquote>
<a id="more"></a>
<p>js实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">	<span class="keyword">var</span> now = <span class="string">"现在时间是： "</span>;</div><div class="line"></div><div class="line">	now += date.getFullYear() + <span class="string">" 年 "</span>;</div><div class="line">	now += (date.getMonth()+<span class="number">1</span>)+ <span class="string">" 月 "</span>;</div><div class="line">	now += date.getDate()     + <span class="string">" 日 "</span>;</div><div class="line">	now += date.getHours()    + <span class="string">" 时 "</span>;</div><div class="line">	now += date.getMinutes()  + <span class="string">" 分 "</span>;</div><div class="line">	now += date.getSeconds()  + <span class="string">" 秒 "</span>;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> week = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"日"</span>, <span class="string">"一"</span>, <span class="string">"二"</span>, <span class="string">"三"</span>, <span class="string">"四"</span>, <span class="string">"五"</span>, <span class="string">"六"</span>);</div><div class="line">	<span class="keyword">var</span> weekIndex = date.getDay();</div><div class="line"></div><div class="line">	now += <span class="string">" 星期"</span> + week[weekIndex];</div><div class="line"></div><div class="line">	$(<span class="string">"#time"</span>).html(now);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure></p>
<p>html代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"time"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>结果截图</p>
<p><img src="http://onl0zwdvm.bkt.clouddn.com/jstime.png" alt="显示时间样式"></p>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习js时候的一些简单的纪录，用js实现显示当前系统时间&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;详细代码如下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="https://ytlm.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>git 命令学习</title>
    <link href="https://ytlm.github.io/2016/07/git-%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ytlm.github.io/2016/07/git-命令学习/</id>
    <published>2016-07-24T06:52:07.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一些在平时学习git时经常需要用的一些命令<br><a id="more"></a></p>
<ol>
<li><p>git stash</p>
<blockquote>
<p>把当前未提交的改动「复制」到另一个地方暂存起来，待要恢复的时候执行 git stash pop</p>
</blockquote>
</li>
<li><p>git commit –amend</p>
<blockquote>
<p>提交之后发现漏掉了某些文件,选择重新add后提交再次提交是不合理的，应该先add后执行git commit –amend</p>
</blockquote>
</li>
<li><p>git reset <strong>filename</strong></p>
<blockquote>
<p>意外地把一个不需要的文件也 add 了，git reset <strong>filename</strong> 把这个文件重staging area位置移除出来，并且不会丢失任何数据</p>
</blockquote>
</li>
<li><p>git checkout <strong>filename</strong></p>
<blockquote>
<p>快速扔掉该文件所有的变更，回到没有修改之前的状态</p>
</blockquote>
</li>
<li><p>git checkout -b xxx</p>
<blockquote>
<p>创建并且checkout到一个新的分支上</p>
</blockquote>
</li>
<li><p>忽略一个目录</p>
<blockquote>
<p>git rm -r –cached <strong>dir</strong> //首先删除已经跟踪并添加过的目录<br>echo <strong>dir/</strong> &gt;&gt; .gitignore //添加忽略文件，并向忽略文件中添加需要忽略的目录<br>git add .gitignore //让git跟踪忽略文件<br>git commit -m ‘ignore <strong>dir</strong> forever’ //提交忽略文件</p>
</blockquote>
</li>
<li><p>git diff <strong>a</strong> <strong>b</strong> <a href="http://www.cnblogs.com/wish123/p/3963224.html" title="原文链接" target="_blank" rel="external">原文链接</a></p>
<blockquote>
<p>(1). git diff (不加任何参数)</p>
<blockquote>
<p>此命令比较的是工作目录(Working tree)和暂存区域快照(index)之间的差异<br>也就是修改之后还没有暂存起来的变化内容。<br>(2). git diff SHA1 SHA2<br>比较两个历史版本之间的差异</p>
</blockquote>
</blockquote>
</li>
</ol>
<p><strong><em>未完待续，后续使用到 git 其他相关都会慢慢积累到这里</em></strong></p>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是一些在平时学习git时经常需要用的一些命令&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git" scheme="https://ytlm.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>static和extern，定义和声明</title>
    <link href="https://ytlm.github.io/2016/07/static%E5%92%8Cextern%EF%BC%8C%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E/"/>
    <id>https://ytlm.github.io/2016/07/static和extern，定义和声明/</id>
    <published>2016-07-23T15:04:48.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下关于声明和定义的区别，以及static和extern的异同<br><a id="more"></a></p>
<p><strong><em>声明和定义</em></strong></p>
<blockquote>
<p>1,广义角度声明包含定义，定义是声明的一个特例。<br>2,定义是会简历存储空间的，而声明则不会，int a;声明a的同时，也定义了a，建立了存储空间；extern b;只是声明了b，并不是定义b，表示b是在其它文件中定义的。</p>
</blockquote>
<p><strong><em>static和extern</em></strong><br><strong><em>static</em></strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">存储位置</th>
<th style="text-align:right">作用范围</th>
<th style="text-align:right">赋值</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局变量</td>
<td style="text-align:center">静态存储区</td>
<td style="text-align:right">从定义位置到文件结束，<br>且能够被其它文件引用。</td>
<td style="text-align:right">若被赋值则为赋值<br>若没有则为0或空</td>
</tr>
<tr>
<td>静态全局变量</td>
<td style="text-align:center">静态存储区</td>
<td style="text-align:right">从定义位置到文件结束，<br>且不能够被其它文件引用，<br>限定于定义的文件内。</td>
<td style="text-align:right">若被赋值则为赋值<br>若没有则为0或空</td>
</tr>
<tr>
<td>局部变量</td>
<td style="text-align:center">非静态存储区</td>
<td style="text-align:right">从定义位置到函数执行结束。</td>
<td style="text-align:right">若被赋值则为赋值<br>若没有则为随机数</td>
</tr>
<tr>
<td>静态局部变量</td>
<td style="text-align:center">静态存储区</td>
<td style="text-align:right">从定义位置到文件结束。</td>
<td style="text-align:right">若被赋值则为赋值<br>若没有则为0或空<br>且只被赋值一次，以后再用到还是上次的值</td>
</tr>
<tr>
<td>静态函数</td>
<td style="text-align:center">栈区</td>
<td style="text-align:right">定义所在文件内。</td>
<td style="text-align:right">-</td>
</tr>
<tr>
<td>非静态函数</td>
<td style="text-align:center">栈区</td>
<td style="text-align:right">可以被出定义所在文件外的<br>其它文件调用。</td>
<td style="text-align:right">-</td>
</tr>
</tbody>
</table>
<p><strong><em>extern</em></strong><br>extern 只在头文件中声明<br>static 只在源文件中定义</p>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下关于声明和定义的区别，以及static和extern的异同&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C" scheme="https://ytlm.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C语言编译过程</title>
    <link href="https://ytlm.github.io/2016/07/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>https://ytlm.github.io/2016/07/C语言编译过程/</id>
    <published>2016-07-23T14:20:38.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>大致分为如下几个过程，编译预处理阶段，编译阶段， 汇编阶段， 链接。<br>详细过程如下</p>
<a id="more"></a>
<p>1，编译预处理（gcc -E main.c -o main.i）</p>
<blockquote>
<ul>
<li>文件包含复制 将源文件中一”#include”格式包含的文件复制到编译的源文件中</li>
<li>宏定义替换 用实际的值替换用”#define”定义的字符串<blockquote>
<p>__DATE__:当前源程序的创建日期。<br>__FILE__:当前源程序的文件名称(包括盘符和路径)。<br>__LINE__:当前被编译代码的行号。<br>__STDC__:返回编译器是否位标准C,若其值为1表示符合标准C，否则不是标准C.<br>__TIME__:当前源程序的创建时间。　</p>
</blockquote>
</li>
<li>决定编译代码 根据”#if”条件决定需要编译的实际代码</li>
<li>删除注释 行注释和块注释</li>
</ul>
</blockquote>
<p>2，编译（gcc -S main.i -o main.s）</p>
<blockquote>
<ul>
<li>对预处理过后的文件进行一系列的词法分析，语法分析，语义分析以及进行相关的优化，生成相应的汇编代码文件</li>
</ul>
</blockquote>
<p>3，汇编（gcc -c main.c -o main.o）</p>
<blockquote>
<ul>
<li>将编译过的汇编代码翻译成目标机器指令的过程</li>
</ul>
</blockquote>
<p>4，链接（ld）</p>
<blockquote>
<ul>
<li>将不同部分的代码和数据收集和组合成为一个单一文件的过程，将相关目标指令文件链接，使其成为一个整体可以被OS执行</li>
<li>连接器ld将各个目标文件组装在一起，解决符号依赖，库依赖关系，并生成可执行文件</li>
</ul>
</blockquote>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大致分为如下几个过程，编译预处理阶段，编译阶段， 汇编阶段， 链接。&lt;br&gt;详细过程如下&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C" scheme="https://ytlm.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C程序在内存中的布局</title>
    <link href="https://ytlm.github.io/2016/07/C%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80/"/>
    <id>https://ytlm.github.io/2016/07/C程序在内存中的布局/</id>
    <published>2016-07-23T11:47:06.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p><strong> C程序在内存中的布局大致如下图所示 </strong><br><img src="http://onl0zwdvm.bkt.clouddn.com/memory.png!blog" alt="内存布局"></p>
<p><em>从上到下依次是栈空间，堆空间，bbs段，data段，文本段</em></p>
<a id="more"></a>
<h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p>1，地址空间由高向低减少，先分配高地址。<br>2，由编译器自动分配释放，主要存放函数参数，局部变量的值。<br>3，C语言函数参数进栈的顺序是从右向左（主要是为了支持可变长参数形式）。</p>
<h3 id="堆（head）"><a href="#堆（head）" class="headerlink" title="堆（head）"></a>堆（head）</h3><p>1，主要用于动态分配内存，malloc等函数，由free释放。</p>
<h3 id="静态存储区包括bbs段和data段"><a href="#静态存储区包括bbs段和data段" class="headerlink" title="静态存储区包括bbs段和data段"></a>静态存储区包括bbs段和data段</h3><h4 id="bbs（bbs）"><a href="#bbs（bbs）" class="headerlink" title="bbs（bbs）"></a>bbs（bbs）</h4><p>1，存放一些未初始化的全局变量。</p>
<h4 id="data（data）"><a href="#data（data）" class="headerlink" title="data（data）"></a>data（data）</h4><p>1，存放一些已经初始化的全局变量，静态变量和常量。</p>
<h4 id="text（text）"><a href="#text（text）" class="headerlink" title="text（text）"></a>text（text）</h4><p>1，存放程序执行代码的区域，区域大小在运行的时候就已经确定了。<br>2，内存区域只读的，也可能包含一些只读的常数变量，字符串常量等。</p>
<p><em>一个非常清晰的程序图</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//main.c</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//全局初始化区</span></div><div class="line"><span class="keyword">char</span> *p1;<span class="comment">//全局未初始化区</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></div><div class="line">  <span class="keyword">int</span> b;<span class="comment">//栈区</span></div><div class="line">  <span class="keyword">char</span> s1[] = <span class="string">"abc"</span>;<span class="comment">//"abc\0"在常量区，s1栈区</span></div><div class="line">  <span class="keyword">char</span> s2[] = <span class="string">"abc"</span>;<span class="comment">//"abc\0"在常量区，s2栈区</span></div><div class="line"><span class="comment">//s1和s2是不想等的</span></div><div class="line">  <span class="keyword">char</span> *p2;<span class="comment">//栈区</span></div><div class="line">  <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;<span class="comment">//"123456\0"在常量区，p3在栈区</span></div><div class="line">  <span class="keyword">char</span> *p4 = <span class="string">"123456"</span>;<span class="comment">//"123456\0"在常量区，p4在栈区</span></div><div class="line"><span class="comment">//p3和p4是一样的，都只想同一个位置"123456\0"所在位置</span></div><div class="line">  p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</div><div class="line">  p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);<span class="comment">//分配得来的10和20字节的区域在堆区</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; C程序在内存中的布局大致如下图所示 &lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://onl0zwdvm.bkt.clouddn.com/memory.png!blog&quot; alt=&quot;内存布局&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从上到下依次是栈空间，堆空间，bbs段，data段，文本段&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C" scheme="https://ytlm.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>在TP框架下使用AJAX验证登陆后台</title>
    <link href="https://ytlm.github.io/2016/07/%E5%9C%A8TP%E6%A1%86%E6%9E%B6%E4%B8%8B%E4%BD%BF%E7%94%A8AJAX%E9%AA%8C%E8%AF%81%E7%99%BB%E9%99%86%E5%90%8E%E5%8F%B0/"/>
    <id>https://ytlm.github.io/2016/07/在TP框架下使用AJAX验证登陆后台/</id>
    <published>2016-07-23T11:34:34.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在TP框架下使用AJAX验证登陆后台"><a href="#在TP框架下使用AJAX验证登陆后台" class="headerlink" title="在TP框架下使用AJAX验证登陆后台"></a>在TP框架下使用AJAX验证登陆后台</h3><blockquote>
<p>主要分为前台页面，js，后台php的实现，代码如下</p>
</blockquote>
<a id="more"></a>
<h5 id="前台页面"><a href="#前台页面" class="headerlink" title="前台页面"></a><em>前台页面</em></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="keyword">var</span> handleUrl = <span class="string">'&#123;:U("Home/Login/handle", "", "")&#125;'</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login"</span>&gt;</span><span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span>  <span class="tag">&lt;<span class="name">th</span>&gt;</span>帐号:<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>验证码:<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"code"</span> <span class="attr">name</span>=<span class="string">"code"</span>/&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;:U('Home/Login/verify', '', '')&#125;"</span> <span class="attr">id</span>=<span class="string">"code"</span> <span class="attr">onclick</span>=<span class="string">"javascript:change_code()"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">class</span>=<span class="string">'reset'</span> <span class="attr">value</span>=<span class="string">"重置"</span> /&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> &gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"errM"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="JS"><a href="#JS" class="headerlink" title="JS"></a><em>JS</em></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$(function()&#123;</div><div class="line">  var username = $(&quot;input[name=&apos;username&apos;]&quot;);</div><div class="line">  var password = $(&quot;input[name=&apos;password&apos;]&quot;);</div><div class="line">  var code = $(&quot;input[name=&apos;code&apos;]&quot;);</div><div class="line">  $(&quot;input[type=&apos;submit&apos;]&quot;).click(function()&#123;</div><div class="line">      event.preventDefault();//取消默认提交表单</div><div class="line">      $.post(</div><div class="line">            handleUrl,</div><div class="line">            &#123;username:username.val(), password:password.val(), code:code.val()&#125;,</div><div class="line">            function(data)&#123;</div><div class="line">                if(data.status == 1)&#123;</div><div class="line">                    window.location.href = data.url;</div><div class="line">                &#125;</div><div class="line">                $(&quot;#errM&quot;).html(data.info);</div><div class="line">            &#125;, &quot;json&quot;);&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h5 id="TP后台实现"><a href="#TP后台实现" class="headerlink" title="TP后台实现"></a><em>TP后台实现</em></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public function handle()&#123;</div><div class="line">	if(!IS_AJAX) $this-&gt;error(&quot;页面不存在。。。&quot;);</div><div class="line">	$code     = I(&apos;code&apos;);</div><div class="line">    $username = I(&apos;username&apos;);</div><div class="line">    $pwd      = I(&apos;password&apos;, &apos;&apos;, &apos;md5&apos;);</div><div class="line">    $data = array();</div><div class="line">    if ( !$this-&gt;checkCode($code) ) &#123;</div><div class="line">    	//检查验证码是否正确</div><div class="line">        $data[&apos;info&apos;]   = &quot;验证码错误,请检查重试。。。&quot;;</div><div class="line">        $data[&apos;status&apos;] = 0;</div><div class="line">        $data[&apos;url&apos;]    = U(&apos;index&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">        //验证码正确</div><div class="line">        $arrUser[&apos;username&apos;] = $username;</div><div class="line">        $User = M(&apos;user&apos;)-&gt;where($arrUser)-&gt;find();</div><div class="line">        if( !$User ) &#123;</div><div class="line">            //检查用户是否存在</div><div class="line">            $data[&apos;info&apos;]   = &quot;用户不存在，请检查重试。。。&quot;;</div><div class="line">            $data[&apos;status&apos;] = 0;</div><div class="line">            $data[&apos;url&apos;]    = U(&apos;index&apos;);</div><div class="line">        &#125; else &#123;</div><div class="line">            //用户存在检查密码是否正确</div><div class="line">            if( $pwd != $User[&apos;password&apos;]) &#123;</div><div class="line">                $data[&apos;info&apos;]   = &quot;密码错误，请检查重试。。。&quot;;</div><div class="line">                $data[&apos;status&apos;] = 0;</div><div class="line">                $data[&apos;url&apos;]    = U(&apos;index&apos;);</div><div class="line">            &#125; else &#123;</div><div class="line">                //登陆通过，把相关内容写入session</div><div class="line">                session(&apos;uid&apos;,      $User[&apos;userid&apos;]);</div><div class="line">                session(&apos;username&apos;, $User[&apos;username&apos;]);</div><div class="line">                session(&apos;role&apos;,     $User[&apos;role&apos;]);</div><div class="line">                $data[&apos;info&apos;]   = &quot;登陆成功,正在跳转。。。&quot;;</div><div class="line">                $data[&apos;status&apos;] = 1;</div><div class="line">                $data[&apos;url&apos;]    = U(&apos;Home/Index/index&apos;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    $this-&gt;ajaxReturn($data, &apos;json&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在TP框架下使用AJAX验证登陆后台&quot;&gt;&lt;a href=&quot;#在TP框架下使用AJAX验证登陆后台&quot; class=&quot;headerlink&quot; title=&quot;在TP框架下使用AJAX验证登陆后台&quot;&gt;&lt;/a&gt;在TP框架下使用AJAX验证登陆后台&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;主要分为前台页面，js，后台php的实现，代码如下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="https://ytlm.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ThinkPHP" scheme="https://ytlm.github.io/tags/ThinkPHP/"/>
    
      <category term="Jquery" scheme="https://ytlm.github.io/tags/Jquery/"/>
    
      <category term="AJAX" scheme="https://ytlm.github.io/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>FIRST</title>
    <link href="https://ytlm.github.io/2016/06/FIRST/"/>
    <id>https://ytlm.github.io/2016/06/FIRST/</id>
    <published>2016-06-04T15:16:53.000Z</published>
    <updated>2017-05-27T06:12:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>  我的第一个私人博客，之前也一直想要有一个私人的博客，想租个vps和域名，可是没有money，自己维护也很麻烦就一直搁置了。</p>
<p>  最近借助github平台和hexo工具实现了这个小小的愿望，终于有了一个自己的blog，哈哈哈。。。</p>
<p>  下面是大致的安装过程。</p>
<a id="more"></a>
<p><strong>大致过程如下</strong></p>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><blockquote>
<ul>
<li>首先在github上创建自己的账号，然后创建一个以自己名字命名的仓库，可以自己搜索怎么建立。</li>
</ul>
</blockquote>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote>
<ul>
<li>首先安装node.js，因为hexo是基于node.js开发的一个静态博客框架</li>
<li>安装hexo，安装的过程中可能需要更换npm源</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo -g</div></pre></td></tr></table></figure>
<h2 id="初始化自己的blog"><a href="#初始化自己的blog" class="headerlink" title="初始化自己的blog"></a>初始化自己的blog</h2><blockquote>
<ul>
<li>创建一个文件夹作为自己以后blog的根目录</li>
<li>进入该blog目录，进行初始化配置</li>
<li>配置根目录下的__config.yml文件</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mkdir blog</div><div class="line"><span class="built_in">cd</span> blog</div><div class="line">hexo init</div><div class="line">hexo install</div><div class="line">hexo new <span class="string">"newAticle"</span> //创建新的文章，执行完之后会在sources/_post/目录下会有newAticle.md文件，打开进行编辑</div><div class="line">hexo clean //清除本地缓存</div><div class="line">hexo generate //生成网站</div><div class="line">hexo serve //开启本地服务，可以在http://localhost:4000/中进行本地预览</div><div class="line">hexo deploy //部署到github上</div></pre></td></tr></table></figure>
<p><strong><em>以后每次添加新文章就按照 / hexo clean / hexo new “” / hexo generate / hexo deploy / 的顺序就可以添加新文章</em></strong></p>
<h2 id="选择hexo主题，next"><a href="#选择hexo主题，next" class="headerlink" title="选择hexo主题，next"></a>选择hexo主题，next</h2><blockquote>
<ul>
<li>安装next主题</li>
<li>启用next主题,根目录下配置文件_config.yml配置theme: next</li>
<li>优化配置next主题,在next主题文件目录下的配置文件_config.yml</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
<hr>
<p><strong><em> 如有疑问欢迎批评指正，谢谢！ </em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  我的第一个私人博客，之前也一直想要有一个私人的博客，想租个vps和域名，可是没有money，自己维护也很麻烦就一直搁置了。&lt;/p&gt;
&lt;p&gt;  最近借助github平台和hexo工具实现了这个小小的愿望，终于有了一个自己的blog，哈哈哈。。。&lt;/p&gt;
&lt;p&gt;  下面是大致的安装过程。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://ytlm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="github" scheme="https://ytlm.github.io/tags/github/"/>
    
      <category term="hexo" scheme="https://ytlm.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
