<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[define中特殊符号的用法]]></title>
    <url>%2F2018%2F02%2Fdefine%E4%B8%AD%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在C语言中宏定义#define 是一个很有用处的一个特性，在看其它一些源码的时候宏定义#define中会出现一些特殊的符号，主要有# ## do{}while(0)，这里记录以下这几种特殊符号的含义和用法 1，# 字符串化操作符 可以将宏定义中传入的参数转换成用一对双引号括起来的字符串 12345678910#include &lt;stdio.h&gt;#define STRING(str) #strint main(int argv, char* argc[]) &#123; char* str1 = STRING(test1); char* str2 = STRING( a bc e); // 参数中间出现空格，会将连续的空格替换成一个 printf("str1 : %s\n", str1); //结果 str1 : test1 printf("str2 : %s\n", str2); //结果 str2 : a bc e return 0;&#125; 2，##符号连接符 将宏定义中的多个参数连结成一个参数 12345678910#include &lt;stdio.h&gt;#define CONCAT(n) t##n#define PRINT(n) printf("t" #n " = %d\n", t ## n) // `##` 前后空格可有可无int main(int argv, char* argc[]) &#123; int CONCAT(1) = 10; // int t1 = 10; int CONCAT(2) = 20; // int t2 = 20; PRINT(1); // printf("t1 = %d\n", t1); PRINT(2); // printf("t2 = %d\n", t2); return 0;&#125; 3，do{}while(0) 不需要do{}while(0)的情况 12345#define TEST(x) action1(x); \ action2(x);if (NULL == p) TEST(p);// 在这种情况下会出现action1()会执行，action2()不会被执行的情况 仅仅使用{}的情况 12345#define SWAP(x, y) &#123;int tmp; tmp = x; x = y; y = tmp;&#125;if(x &gt; y) SWAP(x y);//这种情况下编译直接报错了，因为多了一个`;` 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>define</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识SystemTap]]></title>
    <url>%2F2017%2F12%2F%E5%88%9D%E8%AF%86SystemTap%2F</url>
    <content type="text"><![CDATA[systemtap是一个诊断linux系统性能和功能问题的开源软件，并且允许开发人员编写和重用简单的脚本深入探查linux系统的活动，可以快速安全的提取过滤总结数据，以便能够诊断复杂的性能或功能问题。 环境 Cenots 7.4.1708 Core Kernel 3.10.0-693.11.1.el7.x86_64 安装 sudo yum install systemtap systemtap-runtime sudo yum install kernel-devel-uname -r kernel-debuginfo-uname -r stap -v -e ‘probe vfs.read {printf(“Hello World\n”); exit()}’ 在安装kernel-devel kernel-debuginfo 的时候一定要安装和kernel版本一致的版本，否则是没用的还可以直接下载rpm包安装地址最后一个步骤是检查是否安装成功，如果正确的安装过后，会输出Hello World 流程 基本思想是name events(命名事件)，并给它们处理程序。每当事件发生的时候，linux内核运行处理程序，就像一个子程序一样，之后恢复。处理程序是一系列的脚本语言，用于指定事件完成时要完成的工作，这种工作通常包括是提取数据，打印结果等； systemtap通过stap将脚本装换成C源代码，运行系统的时候创建一个内核模块，当模块加在的时候，它通过挂载到内核的钩子来激活所有的探测事件。最后，这次事件结束的时候，挂载的钩子断开连接执行清楚进程，移除模块，退出所有相关的程序； 语法从语法上来讲很多都是和C语言通用的，条件结构，顺序结构，循环结构，等等 类型模式 begin；在脚本开始的时触发 end；在脚本结束时触发 kernel.function(“sys_sync”)；在调用sys_sync时触发 kernel.function(“sys_sync”).call；在调用sys_sync时触发 kernel.function(“sys_sync”).return；在sys_sync返回时触发 kernel.syscall.* ；在进行任何系统调用时触发 kernel.function(“*@kernel/fork.c:934”)；在执行到fork.c的第934行时触发 timer.ms(200)；每隔200毫秒触发一次 timer.ms(200).randomize(50)；每隔200毫秒触发一次，带有线性分布的随机附加时间(-50到+50) timer.jiffies(1000)；每隔1000个内核jiffy触发一次 例子12345678910111213141516#!/usr/bin/env stapglobal syscalllistprobe begin &#123; printf(&quot;start ... \n&quot;)&#125;probe syscall.* &#123; syscalllist[pid(), execname()]++&#125;probe timer.s(5) &#123; printf(&quot;-----------------------------\n&quot;) foreach ( [pid, cname] in syscalllist ) &#123; printf(&quot;%s[%d] = %d\n&quot;, cname, pid, syscalllist[pid, cname]) &#125; delete syscalllist exit()&#125; begin 开始的时候会打印出”start … “syscall.* 这里会统计所有的系统调用，并按照pid和name进程名称的方式存到syscalllist数组中timer.s(5) 每隔5秒就会调用一次，这里遍历syscalllist数组，打印相关信息这里只打印了当前5秒之内的系统调用，之后就exit()退出了通过stap call.stp来执行call.stp这个脚本，下面是我这里运行的时候截取的一部分输出 stapio[24669] = 93EMT-1[8464] = 11181EMT-0[8464] = 7126Chrome_IOThread[3595] = 4852Timer[8464] = 670chrome[3595] = 11339Chrome_ChildIOT[3818] = 2418Compositor[3818] = 1500chrome[4276] = 1624nginx[21997] = 3avahi-daemon[854] = 9888VirtualBox[8464] = 423X[1785] = 966gnome-shell[2557] = 1373VUsbPeriodFrm[8464] = 512INTNET-RECV[8464] = 611 后记 这里只是简单的接触和学习了一下SystemTap，想要把这个用到实际的项目中还需要继续深入的研究和学习。 参考连接 https://www.ibm.com/developerworks/cn/linux/l-systemtap/index.htmlhttps://sourceware.org/systemtap/https://en.wikipedia.org/wiki/DTracehttps://en.wikipedia.org/wiki/SystemTap 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>linux</category>
        <category>systemtap</category>
      </categories>
      <tags>
        <tag>systemtap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos安装配置mariadb]]></title>
    <url>%2F2017%2F12%2Fcentos%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmariadb%2F</url>
    <content type="text"><![CDATA[这里简单介绍一下在centos环境下mariadb的安装和配置 环境 CentOS 7.4.1708 Core Kernel 3.10.0-693.11.1.el7.x86_64 安装sudo yum install mariadb mariadb-server 这里可能需要安装epel扩展源只需要一行命令，就是那么任性0.0 配置命令 sudo systemctl start mariadb 启动数据库 sudo systemctl enable 开机自启 mysql -uroot -p&#39;password&#39; 通过密码登陆 sudo systemctl restart mariadb 重启数据库 初始配置mysql_secure_installation 初始配置，这里要先启动数据库 Enter current password for root (enter for none): “初始运行，没有密码，直接回车”Set root password? [Y/n] “是否设置密码，这里需要设置密码所以输入y，然后回车”New password: “输入密码”Re-enter new password: “再次输入密码确认”Remove anonymous users? [Y/n] “是否删除匿名用户，这里输入y，然后回车”Disallow root login remotely? [Y/n] “是否禁止root远程登陆，因为可能需要远程登陆，所以这里输入n，然后回车”Remove test database and access to it? [Y/n] “是否删除测试数据库，根据需要”Reload privilege tables now? [Y/n] “是否重新加载权限，数据y，然后回车”至此初始化配置已经完成，可以尝试登陆和学习 字符集配置 打开 /etc/my.cnf,在[mysqld]下添加如下配置 [mydqld]init_connect=’SET collation_connection = utf8_unicode_ci’init_connect=’SET NAMES utf8’character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshake 打开/etc/my.cnf.d/client.cnf,在[client]下添加如下配置 [client]default-character-set=utf8 打开/etc/my.cnf.d/mysql-clients.cnf，在[mysql]下添加如下配置 [mysql]default-character-set=utf8 重启数据库 权限配置 允许外网登陆 grant all privileges on *.* to root@&#39;%&#39; identified by &#39;password&#39;; 授权用户可以授权 grant all privileges on *.* to root@&#39;127.0.0.1&#39; identified by &#39;password&#39; with grant option; 使这些配置生效，这里一定要执行 flush privileges; 外网登陆命令 mysql -h &#39;ip&#39; -u &#39;root&#39; -P 3306 -p&#39;password&#39;-h ip为远程数据库ip地址，-P 3306是数据库默认端口，-u root 登陆用户名，-ppassword 登陆用户对应的密码； 外网登陆的时候可能会遇到防火墙的原因，导致连接失败，需要根据以下配置防火墙 iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT iptables-save &gt; /etc/iptables/iptables.rules systemctl reload iptables || iptables-restore &lt; /etc/iptables/iptables.rules 后记 之前装过一次，在本地登陆进去之后，创建数据库的时候一直有权限错误，在搜索之后并没有得到解决，所以就把这些全部删除，尤其是要把之前的数据库删除，一般默认位置是在/var/lib/mysql目录下面，然后重新安装配置一遍就正常了，这里简单的记录一下以后有问题可以来此查看。 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>mariadb</category>
        <category>linux</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>mariadb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lua学习之协程]]></title>
    <url>%2F2017%2F06%2Flua%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[lua中的另一个高级功能是coroutine(协程)，协同式多线程的意思，不同于线程和进程，协程仅在显示的调用一个让出(yield)函数时才会挂起当前的执行，同一时间内只有一个协程正在运行，非抢占式的。 api介绍 coroutine.create( fun ) 参数： 是一个函数，是这个协程的主体函数。 返回值： 返回一个新的协程，类型为”thread”。 作用： 创建一个新的协程。 coroutine.yield( ... ) 参数： 任意变长参数。 返回值： 状态true或者false表示这个协程有没有挂起成功，然后返回传递的变长参数，全部返回给上次的coroutine.resume()调用。 作用： 挂起一个正在运行的协程，这个是有限制的，比如在调用C函数中和一些迭代器中是不能yield的。 coroutine.resume( co, ... ) 参数： 一个协程，通过coroutine.create()创建的，加上自定义参数，这些自定义参数都会传递给协程的主函数。返回值： 一个boolean型的值表示有没有正确执行，之后的返回值都是coroutine.yield()中的参数。如果第一个值是false，后面的是错误信息。 作用： 运行一个协程直到函数执行完或者函数调用coroutine.yield()主动退出。 coroutine.wrap( fun )， 参数： 一个函数。 返回值： 和coroutinue.resume()相同，只不过没有boolean变量。 作用： 和coroutine.create()相似，只不过返回的是一个函数，每次调用这个函数就继续执行这个协程。传递给这个函数的参数都将作为coroutine.resume()额外的参数。 coroutine.running( ) 参数： 无。 返回值： 返回正在运行的协程否则返回nil。 coroutine.status( co ) 参数： 一个协程。 返回值： 返回这个协程当前的状态，主要有， running 表示正在运行； suspended 表示没有运行或者yield让出的状态； normal 表示协程是活的，但是并不在运行（正在延续其它的协程）； dead 表示协程执行完毕或者因错误停止。 代码12345678910111213141516171819local function test(a) print("test : ", a) return coroutine.yield(2 * a)endlocal co = coroutine.create( function(b, c) print("running : ", coroutine.running()) print("co-body 1 : ", b, c) local r = test(b + 1) print("co-body 2 : ", r) local n, m = coroutine.yield(b - c, b + c) print("co-body 3 : ", n, m) return "begin", "end"end)print("test status 1 : ", coroutine.status(co))print("main 1 : ", coroutine.resume(co, 1, 9))print("main 2 : ", coroutine.resume(co, "r"))print("main 3 : ", coroutine.resume(co, "n", "m"))print("main 4 : ", coroutine.resume(co, "x", "y"))print("test status 3 : ", coroutine.status(co)) 结果如下1234567891011test status 1 : suspendedrunning : thread: 0x1e64df0co-body 1 : 1 9test : 2main 1 : true 4co-body 2 : rmain 2 : true -8 10co-body 3 : n mmain 3 : true begin endmain 4 : false cannot resume dead coroutinetest status 3 : dead 结合上面的介绍和代码可以简单的理解各个函数的作用，并且对lua的协程有一个感性的认知。 示例经典的生产者消费者问题，我们用lua协程的方式来实现一遍123456789101112131415161718192021222324local function send(p) print("product send : ", p) coroutine.yield(p)endlocal product = coroutine.create(function() while(true) do local p = io.read() send(p) endend)local function receive(co) local ok, res = coroutine.resume(co) if ok then print("consumer received : ", res) else print("consumer receive failed : ", res) endendlocal function consumer(co) while (true) do receive(co) endendconsumer(product) 运行结果123456789hello worldproduct send : hello worldconsumer received : hello world1234567890product send : 1234567890consumer received : 12345678901 + 1 = 2product send : 1 + 1 = 2consumer received : 1 + 1 = 2 大致的解释一遍，程序会创建一个product协程，然后consumer函数调用recieve的时候会唤醒生产者协程主函数，主函数会把得到的值yield出去，这一步做了两个事情，一个是把得到的值返回给消费者，另一个是挂起自己，等待下次被激活。 后记 通过lua的协程我们可以用同步的方式写出异步的程序。 当然本文只是简单的介绍lua的协程机制，具体到实际应用的话，还是会有很多变化的，lua-resty-http是使用ngx_lua socket实现的一个http客户端，其中就有用到协程相关，有兴趣可以看看具体的实现。 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lua学习之元表和元方法]]></title>
    <url>%2F2017%2F06%2Flua%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%83%E8%A1%A8%E5%92%8C%E5%85%83%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习lua也有大概一年了，对lua的一些基本的语法很熟练了，也做了一些简单的业务，但是对于lua的高级特性还是不是很熟，最近有时间得以系统的学习学习。本文主要讲述的是lua高级特性之一的元表和元方法。 文字简述 metatable(元表) 本质上来讲元表也是一个表，不过这个表是用来定义对lua的值进行自定义运算行为的地方。 metamethod(元方法) 本质上来讲就是一个lua函数，不过这个函数是用来绑定lua中特定的值，这些特定的值可以称为事件。这个函数我们可以进行我们一些自定义的操作。 元表之中的事件其实是一些定义的值，这些值后面会讲到；实际上我们只能对lua中table类型的值进行修改元表和元方法的操作，其它的一些例如number, string等都已经有自己内置的元表和元方法，且不可改变。 通过元表和元方法，我们可以实现lua的面向对象编程。 代码讲解api 介绍简单的介绍一下会用到的api。 setmetatable(table, metatable) 设置table的元表为metatable并且返回这个table。不能为除table类型之外的值设置元表，如果metatable为nil，则将指定的元表移除 。如果存在__metatable，则会抛出一个错误。getmetatable(obj) 返回一个类型的元表，如果没有元表返回nil。如果存在__metatable，则返回这个域的值。rawget(table, index) 在不触发任何元方法的情况下获取table中的值。也就是跳过元表和元方法。rawset(table, index, value) 在不触发任何元方法的情况下设置table[index]的值为value，index不能是nil和NaN 元方法介绍我们都知道对于两个number型的值，我们可以进行加，减，乘，除等的元算，但是对于table我们是不能直接进行这些预定义的运算的。但是通过通过元表和元方法我们是可以实现的；首先介绍下有哪些特定的值被用于绑定元方法，也称为事件，如下：1234567891011121314151617__index -- 用于取操作__newindex -- 用于赋值操作__metatable -- 限定元表操作__call -- 用于把一个函数当成函数调用的操作__add -- '+' 加__sub -- '-' 减__mul -- '*' 乘__div -- '/' 除__mod -- '%' 取余__pow -- '^' 次方__unm -- '-' 取反__concat -- '..' 连接__tostring -- 字符串序列话__len -- '#' 取长__eq -- '==’ 相等__lt -- '&lt;' 小于__le -- '&lt;=' 小于等于 对于不同的lua版本可能这些事件还有区别，具体详细的可以看lua对应版本的介绍，这里只列出了一些常用的。对于一些特定的事件进行一些简单的介绍 __index 当我们在取一个table中的不存在这个index的值的时候，如果有元表的话，会触发这个操作，会到元表中进行查询，并且返回这个值，元表中月不存在的时候返回nil。 __newindex 当我们对一个table中的一个不存在的index赋值的时候，如果有元表的话，会触发这个操作，如果元表中有定义这个行为，就按照这个进行。 __metatable 使用这个元方法的时候是保护元表，进值对元表中的成员进行获取或者修改 __call 使用这个的时候我们可以吧table当成函数来进行调用。 代码分析简单的元方法1234567891011121314151617181920212223242526272829303132local t1 = &#123;1, 2, 3&#125;local t2 = &#123;5, 6, 7, 9&#125;local t = &#123; __add = function(a, b) local tmp = &#123;&#125; for i = 1, #a do tmp[i] = a[i] + b[i] end for i = #tmp + 1, #b do tmp[i] = b[i] end return tmp end, __tostring = function(a) local str = "" local split = "" for i = 1, #a do str = str .. split .. a[i] split = "|" end return str end&#125;setmetatable(t1, t)print("t1 : ", t1)print("t2 : ", t2)local tmp = t1 + t2print("tmp : ", tmp)setmetatable(t2, t)print(" - t2 : ", t2)setmetatable(tmp, t)print(" - tmp : ", tmp) 运行结果如下12345t1 : 1|2|3t2 : table: 0x16984f0tmp : table: 0x16981c0 - t2 : 5|6|7|9 - tmp : 6|8|10|9 当对两个table进行加(+)的操作的时候，会查找元表中对应的元方法，然后按照元方法的行为去做。其它的一些算术运算都和这个例子大同小异，就不多做介绍了。 __index12345local t1 = &#123;&#125;local t2 = &#123;&#125;t2.a = 10setmetatable(t1, &#123;__index = t2&#125;)print(t1.a) 运行结果如下110 当访问t1中的a的时候，t1中并没有这个值，但是t1有元表，则会到元表中查询a，并返回；__index 也可以是一个函数，用于自定义的一些行为。 __newindex123456789101112131415local t1 = &#123;&#125;t1.c = 30local t2 = &#123;&#125;t2.a = 10t2.b = 20setmetatable(t1, &#123;__newindex = t2&#125;)print(t1.a)print(t2.a)t1.a = "a10"print(t1.a)print(t2.a)print(t1.c)t1.c = "c10"print(t1.c)print(t2.c) 运行结果如下1234567nil10nila1030c10nil 在对t1中的变量进行赋值的时候，如果存在则直接进行赋值，如果不存在则触发__newindex，设置元表中对应的值 __metatable1234567local t1 = &#123;&#125;local t = &#123;&#125;setmetatable(t1, t)print(getmetatable(t1))t.__metatable = "lock"print(" metatable : ", getmetatable(t1))setmetatable(t1, t) 运行结果如下123table: 0xe7f4f0 metatable : locklua: test.lua:11: cannot change a protected metatable 在设置完__metatable域的时候，就不能再对元表进行操作了，会报错。 __call12345678local t1 = &#123;&#125;setmetatable(t1, &#123; __call = function(t, a, b, c, ...) local num = a + b + c print("__call str : ", num) end&#125;)t1(1, 2, 3) 运行结果如下1__call str : 6 t1作为table，但是可以直接当成函数来进行调用，会查找__call元方法 rawget123456local t1 = &#123;&#125;local t2 = &#123;&#125;t2.a = 20setmetatable(t1, &#123;__index = t2&#125;)print("t1 a : ", t1.a)print("rawget t1 a : ", rawget(t1,a)) 运行结果如下12t1 a : 20rawget t1 a : nil 设置完元表后可以取到t1中的a，从元表t2中，但是用rawget的时候会会忽略元表的存在 rawset12345678local t1 = &#123;&#125;local t2 = &#123;&#125;t2.a = 20setmetatable(t1, &#123;__newindex = t2&#125;)t1.b = "bbb"print("t1 b : ", t1.b)print("t2 b : ", t2.b)rawset(t1, b, "ccc") 运行结果如下123t1 b : nilt2 b : bbblua: table index is nil 正常的设置完元表并且设置__newindex域之后，对t1中的不存在的b赋值的时候会触发__newindex操作，但是如果用rawset的话就会报错，rawset(t1, b, “ccc”)，会对t1中的b进行赋值，并不会触发__newindex，而t1中也没有b这个值，所以报错了。 系统代码以一个之前写的例子结束这篇介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121--[[ lua 5.1.5 socket 2.0.2]]--local socket = require("socket")local sub = string.sublocal byte = string.bytelocal concat = table.concatlocal tonumber = tonumberlocal tostring = tostringlocal _M = &#123; _VERSION = "0.1",&#125;local mt = &#123; __index = _M &#125;function _M.new(self) local sock, err = socket.tcp() if not sock then return nil, err end return setmetatable(&#123;_sock = sock, _subscribed = false &#125;, mt)endfunction _M.connect(self, ...) local args = &#123;...&#125; local sock = rawget(self, "_sock") if not sock then return nil, "not initialized" end self._subscribed = false return sock:connect(...)endfunction _M.close(self) local sock = rawget(self, "_sock") if not sock then return nil, "not initialized" end return sock:close()endlocal function _gen_req(args) local nargs = #args local req = "" req = req .. "*" .. nargs .. "\r\n" for i = 1, nargs do local arg = args[i] if type(arg) ~= "string" then arg = tostring(arg) end req = req .. "$" req = req .. #arg req = req .. "\r\n" req = req .. arg req = req .. "\r\n" end-- print("req : ", req) return reqendlocal function _read_reply(self, sock) local line, err = sock:receive() if not line then if err == "timeout" then sock:close() end return nil, err end local prefix = byte(line) if prefix == 42 then -- char "*" local n = tonumber(sub(line, 2)) if n &lt; 0 then return nil end local vals = &#123;&#125; local ind = 1 for i = 1, n do local res, err = _read_reply(self, sock) if res then vals[ind] = res ind = ind + 1 elseif not res then return nil, err end end return vals elseif prefix == 36 then -- char "$" local size = tonumber(sub(line, 2)) if size &lt; 0 then return nil, sub(line, 2) end local data, err = sock:receive(size) if not data then if err == "timeout" then sock:close() end return nil, err end local crlf, err = sock:receive(2) if not crlf then return nil, err end return data elseif prefix == 45 then -- char "-" return nil, sub(line, 2) elseif prefix == 43 then -- char "+" return sub(line, 2) elseif prefix == 58 then -- char ":" return tonumber(sub(line, 2)) else return nil, "unknow prefix : \"" .. tostring(prefix) .. "\"" endendlocal function _do_cmd(self, ...) local args = &#123;...&#125; local sock = rawget(self, "_sock") if not sock then return nil, "not initialized" end local req = _gen_req(args) local bytes, err = sock:send(req) if not bytes then return nil, err end return _read_reply(self, sock)endsetmetatable( _M, &#123; __index = function(self, cmd) local method = function (self, ...) return _do_cmd(self, cmd, ...) end _M[cmd] = method return methodend&#125;)return _M 这是仿照lua-resty-redis，用luasocket实现的一个简单的lua redis客户端。每次用的时候需要 require这个文件，并且调用new，设置相应元表，之后就可以进行简单的redis操作了。 后记 本文代码部分比较多，尽可能的用代码来解释lua中元表和元方法的一些用法，如果理解起来还是不清楚可以查看lua官方文档，也可以联系我。 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp建立连接为什么需要三次握手]]></title>
    <url>%2F2017%2F05%2Ftcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[前言 众所周知tcp传输层协议在建立连接的时候需要三次才能建立起一个真正的可靠连接，可是为什么是三次呢，不可以是两次，四次等等呢，可以自己思考一番，带着疑问可以看下文。 三次握手 在《计算机网络》一书中其中有提到，三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。 问题的本质是，信道是不可靠的，但是我们要建立可靠的连接发送可靠的数据，也就是数据传输是需要可靠的。在这个时候三次握手是一个理论上的最小值，并不是说是tcp协议要求的，而是为了满足在不可靠的信道上传输可靠的数据所要求的。 我们再来考虑，如果不是三次握手会出现什么情况呢： 假设有A和B两端要进行通信，1, 第一次：首先A发送一个(SYN)到B，意思是A要和B建立连接进行通信； 如果是只有一次握手的话，这样肯定是不行的，A压根都不知道B是不是收到了这个请求。 2, 第二次：B收到A要建立连接的请求之后，发送一个确认(SYN+ACK)给A，意思是收到A的消息了，B这里也是通的，表示可以建立连接； 如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。 3, 第三次：A如果收到了B的确认消息之后，再发出一个确认(ACK)消息，意思是告诉B，这边是通的，然后A和B就可以建立连接相互通信了； 这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通信了，已经可以建立一个可靠的连接，并且可以相互发送数据。4, 第四次：这个时候已经不需要B再发送一个确认消息了，两边已经通过前三次建立了一个可靠的连接，如果再发送第四次确认消息的话，就浪费资源了。 如果第二个报文段B发出的(SYN+ACK)分别发送的话，也是可以理解为四次，但是被优化了，一起发送了。 超时重传机制， (1) 如果第一个包，A发送给B请求建立连接的报文(SYN)如果丢掉了，A会周期性的超时重传，直到B发出确认(SYN+ACK)；(2) 如果第二个包，B发送给A的确认报文(SYN+ACK)如果丢掉了，B会周期性的超时重传，直到A发出确认(ACK)；(3) 如果第三个包，A发送给B的确认报文(ACK)如果丢掉了， A在发送完确认报文之后，单方面会进入ESTABLISHED的状态，B还是SYN_RCVD状态 如果此时双方都没有数据需要发送，B会周期性的超时发送(SYN+ACK)，直到收到A的确认报文(ACK)，此时B也进入ESTABLISHED状态，双方可以发送数据； 如果A有数据发送，A发送的是(ACK+DATA)，B会在收到这个数据包的时候自动切换到ESTABLISHED状态，并接受数据(DATA)； 如果这个时候B要发送数据，B是发送不了数据的，会周期性的超时重传(SYN+ACK)直到收到A的确认(ACK)B才能发送数据。 三次握手牵扯到的状态转换 LISTEN 表示socket已经处于listen状态了，可以建立连接； SYN_SENT 表示socket在发出connect连接的时候，会首先发送SYN报文，然后等待另一端发送的确认报文(ACK)，表示这端已经发送完SYN报文了； SYN_RCVD 表示一端已经接收到SYN报文了； ESTABLISHED 表示已经建立连接了，可以发送数据了。 四次挥手 说完TCP建立连接的时候为什么是三次，相对的就会想到为什么断开连接的时候是需要四次呢，而不是三次，五次等等呢； 本质的原因是tcp是全双公的，要实现可靠的连接关闭，A发出结束报文FIN，收到B确认后A知道自己没有数据需要发送了，B知道A不再发送数据了，自己也不会接收数据了，但是此时A还是可以接收数据，B也可以发送数据；当B发出FIN报文的时候此时两边才会真正的断开连接，读写分开。 四次挥手牵扯到的状态装换 FIN_WAIT_1 表示在等待另一方的FIN报文，和FIN_WAIT_2的区别是，FIN_WAIT_1表示socket现在要主动关闭连接，在发送完FIN报文后socket进入FIN_WAIT_1状态，当收到另一方发送FIN的ACK之后立即进入FIN_WAIT_2状态； FIN_WAIT_2 同上，此时需要做的事情是可能还会接收数据，然后等待另一方的FIN； TIME_WAIT 存在主动关闭的一方，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL(Max Segment Lifetime))后即可回到CLOSED可用状态了，需要等一段时间时原因是网络是不可靠的，不能保证这个ACK发送成功了，如果失败了，对端会超时重传FIN； CLOSING 表示在发送FIN之后，没有收到对方的ACK，而是收到了对方的FIN，这中情况很少见，只有在两端几乎同时关闭同一个socket的时候才会出现CLOSING状态； CLOSE_WAIT 表示收到对方的FIN之后，回给对方ACK，此时处于CLOSE_WAIT状态，等待关闭，要看自己是否还有数据要发送； LAST_ACK 表示收到对方的FIN之后，回给对方ACK，然后自己也要关闭发送FIN，等待另一方的ACK时候的状态； CLOSED 这个状态表示连接已经断开。 最后放一张状态转换图 后记 在状态转换图中省略了数据的发送； 对于tcp/ip的学习还需要努力，可能文中有些表达不够严谨，还望海涵。 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装systemmap生成openresty的火焰图]]></title>
    <url>%2F2017%2F04%2F%E5%AE%89%E8%A3%85systemtap%E7%94%9F%E6%88%90openresty%E7%9A%84%E7%81%AB%E7%84%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[SystemTap简单介绍 systemtap是一个诊断linux系统性能和功能问题的开源软件，并且允许开发人员编写和重用简单的脚本深入探查linux系统的活动，可以快速安全的提取过滤总结数据，以便能够诊断复杂的性能或功能问题。 基本思想是name events(命名事件)，并给它们处理程序。每当事件发生的时候，linux内核运行处理程序，就像一个子程序一样，之后恢复。处理程序是一系列的脚本语言，用于指定事件完成时要完成的工作，这种工作通常包括是提取数据，打印结果等。 systemtap通过将脚本装换成C，运行系统的时候创建一个内核模块，当模块加在的时候，它通过挂载到内核的钩子来激活所有的探测事件。最后，这次事件结束的时候，挂载的钩子断开连接，移除模块。 systemtap工具功能很强大，目前刚接触，在此仅仅通过官网做一些简单的介绍。 安装 环境 centos 7，直接用yum install systemtap systemtap-runtime安装，如果遇到依赖包的问题，安装所需要的依赖就好了； 另外需要注意一个重要的问题是需要安装kernel-debuginfo和kernel-debuginfo-common；可以直接用yum安装也可以下载rpm包安装；但是 必须要和kernel版本一样 安装完成后可以用stap -v -e &#39;probe vfs.read {printf(&quot;read performed\n&quot;); exit()}&#39;测试，如果不出意外的话会正常输出的 表示在这里被坑了好久，全部安装好后运行的时候一直报错，累。。。 Openresty介绍 OpenResty是一个动态的基于nginx和lua的网络平台。把nginx和lua集成在一起，可以通过lua完成一些复杂的需求，而不用再去开发C层面的module了，同时性能也很理想。 目前应该直接集成LuaJIT了，简单来说LuaJIT是lua的一个更高性能的版本。 安装 直接到官网下载源码进行编译安装就行了，如果遇到一些依赖，就直接安装依赖就行了。 目前在做nginx的相关工作，所以对openresty了解的比较多一点，如有兴趣，欢迎共同交流。 火焰图介绍 火焰图(Flame Graphs)是一个通过可视话堆栈的方法，可以直观的看出每个函数占用cpu的时间，内存，off-cpu等等，对于我们排查软件问题很有帮助。 显示的是，Y轴是堆栈的深度，X轴是样本数量。每个样本（函数）是一个矩形。鼠标点击可以看到一些详细的信息。通过这些可以看出那些需要调整优化。 对于火焰图也是最近才了解到的，有些解释可能很牵强，误怪，后面会慢慢的了解学习的。 生成 openresty提供了一套完整的工具用于探测运行的状况。可以直接下载并根据介绍运行。 然后下载FlameGraph火焰图生成工具，用于把前面采样到的信息绘制成火焰图。 然后在浏览器中打开进行观察分析。 在采样信息的时候需要让nginx在压力很大的情况下，这样得出的结果才会有更大的参考性。 分析火焰图 采样C层面的信息进行分析 sudo ./sample-bt -p 15507 -t 60 -u -a ‘-DMAXACTION=100000’ &gt; /tmp/nginx.bt -p 表示nginx的worker的pid-t 表示采样时间-u 表示在用户空间-a 传递一些参数，因为我自己的机器的原因所以需要传递这个参数，要不然会报错的 sudo ./stackcollapse-stap.pl /tmp/nginx.bt &gt; /tmp/nginx.cbt sudo ./flamegraph.pl /tmp/nginx.cbt &gt; /tmp/nginx.svg 用浏览器打开/tmp/nginx.svg 我用wrk给nginx的压力还不是很大大概CPU才20%左右，所以这个不是很准确的；但是也可以看出一些问题，比如看出在发送数据的时候还是有问题的，都在body_filter阶段，可能因为我用了很多的buffer的原因 采样lua层面的信息进行分析，在编译luaJIT的时候需要添加CCDEBUG=-g参数 sudo ./ngx-sample-lua-bt -a ‘-DMAXACTION=100000’ -p 4790 –luajit20 -t 60 &gt; /tmp/lua.bt 各个参数的意思和上面的一样。 sudo ./fix-lua-bt /tmp/lua.bt &gt; /tmp/lua-fix.bt sudo ./stackcollapse-stap.pl /tmp/lua-fix.bt &gt; /tmp/lua-fix.cbt sudo ./flamegraph.pl /tmp/lua-fix.cbt &gt; /tmp/lua-fix.svg 浏览器打开/tmp/lua-fix.svg图的话在这里就不再贴出来了 后记 上面用sample-bt生成的是on-cpu的相关数据，也可以用sample-bt-off-cpu生成off-cpu的相关分析数据，具体的区别可以到相关网站进行详细的了解； 首先呢，这个火焰图是一个很好的分析工具，相信可以为我们再排查问题的时候提供很大的帮助，目前我也是刚接触这个工具，还在慢慢摸索学习当中； 另外一个就是在安装遇到过很多的坑，也相当无语，但是都通过google慢慢的一个一个解决了，要有一颗永不放弃的心不是吗； 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>openresty</tag>
        <tag>systemmap</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于nginx缓存配置指令用法详解]]></title>
    <url>%2F2017%2F04%2F%E5%85%B3%E4%BA%8Enginx%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[nginx简介众所周知nginx近些年在服务器领域占据着很重要的作用，目前我主要接触的关于nginx是作为代理服务器来用的，至于再详细的，有兴趣的可以查阅相关文档nginx，就不在这里赘述。本文主要讲述的是把nginx配置成一个缓存服务器组件来用，尽可能详细的把nginx关于缓存的指令解释清楚。 配置指令详解 proxy_buffering on | off 控制着缓存的总开关，如果设置off缓存就不会生效；设置on缓存相关的配置才会生效； 缓存的开关也可以通过设置”X-Accel-Bufferinf”这个header为”yes” | “no”来控制； “X-Accel-Buffering”这个header可以被proxy_ingore_headers指令忽略； proxy_cache zone | off 定义一个共享内存用于缓存，其中主要存一些缓存文件的主要信息，用于检索； 同一个共享内存可以被用于不同的地方， zone 可以支持配置变量； off 的意思是禁用从上层继承的缓存配置； proxy_cache_background_update on | off 允许在后台发送子请求来更新过期的缓存文件； 这个一般都不常用，一般一个请求过来判断一下缓存时间，如果 过期了再从后端取就行了； proxy_cache_bypass string … 如果配置的字符串传中有一个不为空并且不等于”0”，这时候这个请求的相应就不会从缓存中取，应该到后端去取数据； proxy_no_cache string … 如果响应的数据中有任何一个满足让字符串中的值至少有一个不为空并且不等于”0”，那么这个响应就不会被缓存下来； proxy_cache_key string 配置缓存的key，缓存相关的内容都是根据这个key来进行查找的； key的配置很有灵活性，不同的配置可以达到不同的效果； proxy_cache_lock on | off 设置为on的时候，表示在同一时间如果请求同一个cache key的多个请求在没有缓存的情况下只有一个请求会通过后端取数据，其它的请求直接取上个请求的缓存，或者等到超时，直接也去后端去取数据； proxy_cache_lock_timeout time 这个超时时间就是上面的超时时间，如果proxy_cache_lock打开的时候，同一时间同一资源只有一个请求会到后端取数据，其它的请求如果达到这个超时时间之后也会直接到后端取数据； 过了超时时间之后去到后端取下来数据不会缓存下来； proxy_cache_lock_age time 这个的意思是在time时间内一个请求还没有将数据完全从后端取下来并且缓存，那么下一个请求就会被发送到后端，并且这时候也要把数据缓存下来； 这个lock age和上个lock timeout一直没有搞清楚根本的区别，这里只是简单的解释一下，我好像用的也不多，如果谁能够解释一下还望不吝赐教，谢谢0.0； *** proxy_cache_methods GET | HEAD | POST … 如果客户端请求的方法在这个配置的方法列表中，这个请求才有可能被缓存，缓存还受其它的条件制约； proxy_cache_path path [一堆的可选参数] proxy_cache_path /data/nginx/cachet levels=1:2 use_temp_path=off keys_zone=data:60m inactive=365d max_size=10m； 上面是一个典型的配置，下面来解释一下每个的含义 ： /data/nginx/cachet : 这个表示缓存文件实际的存储路径； levels=1:2 : 这个表示缓存文件的分级存储，如果不这样设置的话所有的文件都在同一个文件夹下面，看着比较乱，如果配成这样，缓存文件在实际上大概像这样 /data/nginx/cache/c/29/b7f54b2df7773722d382f4809d65029c ； ues_temp_path=off : 禁用缓存响应到临时目录，直接缓存到缓存目录； keys_zone=data:60m : 设置一个共享内存和大小，里面存储的是缓存文件的一些key信息，在测试的时候发现1m的共享内存大概能够存8k左右个key； inactive=365d : 设置缓存时间，这个也受其它的条件限制，比如说响应头有Cache-Control: max-age=10，这样只能缓存10s； max_size=10m; 设置这个缓存目录的总大小，大小要根据配置的共享内存进行合理的配置；如果超过这个大小会通过LRU算法进行淘汰； proxy_cache_valid [code … ] time 设置特定的响应状态码缓存特定的时间； 后记 上面就是我平常用到的关于nginx缓存的配置，组合起来还是能够达到很多需求的； 这里只是介绍我平常接触到很多的指令，还可能有一些我没有接触过的关于缓存的配置指令，欢迎补充； 另外在配置缓存目录的时候通过proxy_cache_path和proxy_cahce配置多个来达到把不同的缓存存储到不同的目录，这个时候就涉及到负载均衡了，要不然不同的目录缓存的大小不一样； 参考链接 http://nginx.org/en/docs/http/ngx_http_proxy_module.html 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISO的OSI七层网络协议模型]]></title>
    <url>%2F2017%2F04%2FISO%E7%9A%84OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在网络的大环境中扮演者重要的角色的是网络协议，在这里简单的介绍一下关于ISO七层网络协议模型，当然还有TCP/IP四层网络协议，这里不再赘述。 目的在互联网中有千千万万的主机，也有千千万万应用程序，如果不同的主机不同的应用程序不遵守一个规则，就没法交流，那么也就不能称之为互联网了，这时候网络协议的重要性就体现出来了，我们都遵循同样的协议，这样主机和应用程序之间的交流就没有问题了。 实现在网络协议实现的过程中将不同的功能抽象出来，单独实现，只需要提供接口为其它的功能提供服务，具体实现是对其它的服务透明的；这样的好处是每一个服务实现起来只完成特定的功能，实现起来简单；另外在维护的过程中如果出错也更容易定位并发现问题，所以ISO在定制网络协议的时候定义了OSI(Open System Interconnection)协议模型，该模型共分七层，从下至上一次是: 1,物理层; 2,数据链路层; 3,网络层; 4,传输层; 5,会话层; 6,表示层; 7,应用层。下面简单的介绍每层完成的功能。 1，物理层(Physical Layer)为数据链路层提供了一个数据传输的物理媒体，在其上传送比特流，该层数据的单位是比特(bit)。另外该层规定了激活，维持，关闭通信端点之间的机械特性，电气特性，功能特性以及过程特性。 2，数据链路层(Data Link Layer)该层在不可靠的物理介质上提供可靠的传输，负责在网络节点之间的线路上通过检测，流量控制和重发等手段，无差错的传送数据，该层数据的单位是帧(frame)，所以每一帧数据必须同时带有同步，地址，差错控制以及流量控制等控制信息；总结起来是: 物理寻址，数据成帧，流量控制，数据检错，重发等。 3，网络层(Network Layer)为了将数据从源端系统发送到目的端系统，网络层的主要任务是完成网络寻址，对子网间的数据包进行路由选择，使得分组数据包，该层数据的单位是数据包(packet)， 能够准确无误的按照地址找到目的地，并将数据交付给上层协议；另外还可以实现拥塞控制，网际互连等功能。 4，传输层(Transport Layer)该层是端到端的一个层次，主要负责将上层数据分段并提供端到端的，可靠的或不可靠的传输，传输的单位是报文(segment)，该层是网络协议分层中最关键的一层，还要处理端到端的差错控制和流量控制问题。 5，会话层(Session Layer)该层主要对传输的报文提供同步管理的服务，在两个不同的主机的互相通信的应用进程之间进行会话的管理，例如确定是半双工还是全双工等；此外还利用在数据中添加校验点来实现数据的同步。 6，表示层(Presentation Layer)该层主要的作用是把数据进行转换，保证一个主机的应用程序数据可以被另一个主机的一个应用程序所理解，即把不同计算机中内部的不同表示形式转换成网络通信协议中的标准形式。主要包括数据的加密(解密)，压缩(还原)，格式转换等。 7，应用层(Application Layer)该层直接面向用户，主要任务是为操作系统和用户之间提供应用接口。 数据传输过程发送数据 在OSI参考模型中，当一台主机需要传送数据(DATA)时，数据首先通过应用层的接口进入应用层，在应用层数据被加上应用层报头(Application Header, AH)，形成应用层协议数据单元(Protocol Data Unit, PDU)，然后提交到下一层，表示层； 表示层并不关心上层(应用层)的数据格式，而是把整个应用层提交的过来的数据进行整体的封装，添加报文头部(Presentation Header, PH)，然后提交到下一层，会话层； 同样的，会话层，传输层，网络层，数据链路层都分别把上层提交过来的数据加上自己的报头，分别是: 会话层报头(Session Header, SH)，传输层报头(Transport Header, TH), 网络层报头(Network Header, NH),数据链路层报头(Data link Header, DH), 然后提交到下一层。 其中数据链路层还会加上数据链路层报尾(Data link Termination, DT)最终形成一帧数据，在物理层上进行传送。 接收数据 当一帧数据通过物理层传送到目标主机的物理层上时，该主机的物理层把它递交给上层, 数据链路层。数据链路层负责去掉数据的帧头部(DH)和尾部(DT), 同时进行数据校验，如果需要的话会发送反馈给源端主机，如果校验没有出错，则递交到上层，网络层。 同样的，网络层，传输层，会话层，表示层，应用层也要做相应的动作，并执行对应层的功能，最终原始数据递交到目标主机的具体的应用程序中。 后记当然对于不同的设备，它工作在不同的协议层面上，比如路由器是工作在网络层，交换机是工作在数据链路层，集线器是工作在物理层等等。同时在数据的传输过程中不像这里说的那么简单，这里只是简答的介绍，实际上远比这里介绍的复杂，有兴趣的可以查阅相关资料进行详细的了解，相信会有很大的收获的。 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx基于tcp的转发,适用于HTTPS]]></title>
    <url>%2F2017%2F04%2Fnginx%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E8%BD%AC%E5%8F%91-%E9%80%82%E7%94%A8%E4%BA%8EHTTPS%2F</url>
    <content type="text"><![CDATA[nginx的主要功能1，正向代理2，反向代理3，负载均衡4，WEB服务器 通常用nginx主要做反向代理，负载均衡配合反向代理可以做到很多事情；nginx做WEB服务器可以实现动静文件分离；nginx有很多可选的模块，可以对nginx的功能进行扩展；openresty是一个基于nginx与lua的高性能平台，用lua进行扩展； ssl简单介绍1，主要的作用是为了互联网安全；2，SSL是介于HTTP和TCP之间的一个可选层，对于TCP/IP协议来说；3，SSL与TLS之间的关系是TLS(Transport Layer Security)继承并增强了SSL(Secure Socket Layer)协议； 具体的协议交互过程就不再这里展开了，详见参考连接；这里主要说下客户端在SSL协商初期发送的Client Hello请求，其中有个扩展选项，里面有个server name这个可用于转发。 配置nginx转发tcp1，版本，nginx version: nginx/1.11.12；我测试用的是这个版本。2，编译，配置./configure --with-stream --with-stream_ssl_preread_module --with-stream_ssl_module最主要的使用这几个模块，有需要可以添加其它的模块；然后编译安装make &amp;&amp; make install。3，配置，具体配置命令参考pread module和stream module，启动的时候指定下面的配置文件 1234567891011121314151617181920212223user root;worker_processes auto;error_log logs/error.log;pid logs/nginx.pid;worker_rlimit_core 2G;worker_rlimit_nofile 65535;events &#123; worker_connections 81920;&#125;stream &#123; log_format main '$remote_addr - [$time_local] $connection ' '$status $proxy_protocol_addr $server_addr '; access_log logs/access.log main; resolver 114.114.114.114; resolver_timeout 60s; variables_hash_bucket_size 512; server &#123; listen 443; ssl_preread on; proxy_pass $ssl_preread_server_name:443; #大致看了一下源码，这里为什么需要配置端口也没有研究明白，求解释？ &#125;&#125; 4，目前测试基本上都是可以的，在日志中会有一些错误，不会影响正常服务，还再研究中。 参考连接 https://nginx.org/en/docs/https://github.com/openresty/lua-nginx-modulehttp://www.ruanyifeng.com/blog/2014/02/ssl_tls.htmlhttp://www.wosign.com/faq/faq2016-0309-04.htmhttps://segmentfault.com/a/1190000002554673 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo travis github]]></title>
    <url>%2F2017%2F03%2Fhexo-travis-github%2F</url>
    <content type="text"><![CDATA[利用hexo, travis, github联合的方式进行博客的创建并且自动发布. 1,首先是在github创建对应的github pages, 网上有很多教程,这里就不再赘述.2,安装hexo环境用于生成静态博客,这里简单的列举下自己遇到的坑: (1). yml格式的配置冒号(:)后必须要有一个空格.(2). hexo generate不生效的时候要用hexo clean清空缓存.(3). hexo deploy失败的时候注意git公私钥的配置和_config.yml中deploy的配置.(4). 选择hexo的主题next,对于next主题的配置可以根据官网说经进行合理的配置. 3,travis的使用 (1). 在(yourself).github.io的git上建立一个hexo分支, master分支用于页面的显示, hexo分支用于hexo生成博客和配置,便于同步.(2). travis ci的登陆通过github帐号登陆,然后开启(yourself).github.io的travis; 然后在hexo的分支上创建并提交.travis.yml文件,注意github token的生成和使用(3). 最后就是在hexo的分支上进行写博客和提交到hexo分支上,剩下的发布到master上通过travis自动发布. 参考这里还有这里 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>travis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wamp更改web根目录]]></title>
    <url>%2F2016%2F07%2FWamp%E6%9B%B4%E6%94%B9web%E6%A0%B9%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[原文链接Wampserver安装好后，“www目录”默认为X:/wamp/www，（这里的X是盘符）也就是wampserver安装目录下的www文件夹。实际使用中，默认设置往往不是我们想要的，可能改成其他文件夹更适合我们。 比如e:/xx 或者 d:/php等等。 下面以原来的默认目录为d:/wamp/www改为e:/xx为例。 1, 打开wamp/scripts/config.inc.php第47行，$wwwDir = $c_installDir.’/www’;修改为：$wwwDir = ‘e:/xx’;即可。但这时新问题来了，Apache默认根目录还没改过来！继续看第2步！ 2, 修改Apache默认根目录打开wamp/bin/apache/apache2.2.11/conf/httpd.conf,修改DocumentRoot后面双引号中的值为你所要的。比如将DocumentRoot “D:/wamp/www/”改成DocumentRoot “e:/xx/”同时将&lt;Directory “D:/wamp/www/“&gt;改成&lt;Directory “e:/xx/“&gt; 3, 重启wampserver即可生效。 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Wamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WampServer-localhost-图标不显示解决办法]]></title>
    <url>%2F2016%2F07%2FWamp-localhost-%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在用WampServer学习PHP的时候碰到，打开localhost的时候文件图标不显示，解决办法如下 原文链接 1，在安装目录中找到1\wamp\bin\apache\Apache2.2.17\conf\extra\httpd-autoindex.conf 2，打开进行修改,将以下1234567Alias /icons/ “C:/Dev/Projets/WampServer2-64b/install_files_wampserver2/bin/apache/Apache2.2.17/icons/”&lt;Directory “C:/Dev/Projets/WampServer2- 64b/install_files_wampserver2/bin/apache/Apache2.2.17/icons”\&gt; Options Indexes MultiViews AllowOverride None Order allow,deny Allow from all&lt;/Directory&gt; 修改为1234567Alias /icons/ “icons/”&lt;Directory “icons”\&gt; Options Indexes MultiViews AllowOverride None Order allow,deny Allow from all&lt;/Directory&gt; 3，上面用的相对目录, 因为在 httpd.conf 里面设置了ServerRoot “D:/wamp/bin/apache/apache2.2.17”或者用绝对目录也行.\wamp\bin\apache\Apache2.2.17\icons 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Wamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 各层的作用]]></title>
    <url>%2F2016%2F07%2FTCP-IP-%E5%90%84%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[计算机网络中的TCP/IP协议学习，纪录每层的作用 数据链路层 1，负责接收IP数据报添加头部和尾部然后通过网络发送，或者从网络上接收物理数据帧，抽出ip数据报交给IP层。传输有地址的帧以及错误检测。2，流量控制，有基于反馈的流控制盒基于速率的流控制。3，错误检测和纠正 网络层 1，负责相邻计算机之间的通信。2，处理来自传输层分组发送的请求；然后对数据进行分组装入IP数据报，并填充包头，之后选择合适的路径然后发送。3，处理输入数据报；检查合法性，然后寻址发送。4，处理路径，流控，拥塞等问题。 传输层 1，负责点到点的传输。2，格式化信息流。3，提供可靠传输。规定接收端必须发挥确认，如果分组丢失必须重传。 应用层 1，提供端到端的传输。2，向用户提供一些常用的应用程序，如email,ftp,telnet,smtp,pop3,dns等等 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 使用总结]]></title>
    <url>%2F2016%2F07%2FMySQL-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[下面是在学习MySQL的时候一些命令的纪录 1，增1234INSERT INTO &quot;tableName(列1,列2,...)&quot; VALUES(值1,值2,...)/* 1,列和值需要意义对应。 2，列可以省略，省略时值应该和数据表中的值顺序保持一致。*/ 2，删12DELETE FROM &quot;tableName&quot; WHERE &quot;condition1&quot; AND &quot;condition2&quot; .../* 在执行删除语句的时候一定要写好where后面的条件。 */ 3，改12UPDATE &quot;tableName&quot; SET &quot;key = value&quot; WHERE &quot;condition1&quot; AND &quot;condition2&quot; .../* 根据where后面的条件，对表中某些字段数据进行修改。*/ 4，查12345SELECT &quot;fields&quot; FROM &quot;tableName&quot; WHERE &quot;condition&quot;/* 单表查询，根据条件查询某张表中的某几列数据。where和列(fields)可以省略。 */SELECT &quot;fields&quot; FROM &quot;table1, table2,...&quot; WHERE &quot;condition1&quot; AND &quot;condition2&quot; .../* 多表查询，根据表与表之间的关联关系查询所需要的数据。*/ 5，数据库123CREATE DATABASE &quot;databaseName&quot; /* 创建数据库 */DROP DATABASE &quot;databaseName&quot; /* 删除数据库 */ 6，数据表12345CREATE TABLE table_name (columnName columnType) /* 创建数据表，column_type为列类型及属性 */DROP TABLE &quot;tableName&quot; /* 删除数据表 */ALTER TABLE &quot;tableName&quot; RENAME TO &quot;newTableName&quot; /* 修改表名称*/ 7，ALTER1234567891011ALTER TABLE &quot;tableName&quot; DROP &quot;columnName&quot; /*删除表中的某个字段 */ALTER TABLE &quot;tableName&quot; ADD &quot;columnName columnType&quot; FIRST/[AFTER &quot;columnName&quot;]/*在数据表中第一位或者在某个字段之后添加某个字段 */ALTER TABLE &quot;tableName&quot; MODIFY &quot;columnName&quot; &quot;newColumnType&quot; /* 修改表中某个字段的类型属性 */ALTER TABLE &quot;tableName&quot; CHANGE &quot;columnName&quot; &quot;columnName newColumnType&quot;/* 修改表中的的某个字段名并添加可以添加新的类型，还可以值修改字段类型 */ALTER TABLE &quot;tableName&quot; RENAME TO &quot;newTableName&quot; /* 修改表名称*/ 8，权限123GRANT &quot;power&quot; ON &quot;databaseName&quot; TO &quot;user&quot; /* 给用户user添加数据库databaseName对应的权限power*/REVOKE &quot;power&quot; ON &quot;databaseName&quot; FROM &quot;user&quot; /* 移除用户user在数据库databaseName上的权限power */FLUSH PRIVILEGES /* 在不重启MySQL服务的情况下使得权限操作生效 */ 9, 显示表详细结构12345SHOW TABLES; 显示所有的表DESCRIBE table_name; 显示表结构下的所有字段信息 相当于SHOW FIELDS FROM table_nameSHOW FULL FIELDS FROM table_name 显示表结构下的所有字段信息 包含注释 10，其他123456GROUP BY &quot;columnName&quot; /* 对某一列查询结果进行分组统计 */ORDER BY &quot;columnName&quot; ASC/DESC /* 对某一列查询结果进行排序操作，升序ASC，降序DESC */SUM(&quot;columnName&quot;) /* 对某一分组进行统计 */COUNT(&quot;columnName&quot;) /* 对某一分组进行计数 */AVG(&quot;columnName&quot;) /* 对某一分组进行求平均值操作 */.......................等等函数 后续在学习中会继续进行补充，谢谢！ 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 显示当前系统时间]]></title>
    <url>%2F2016%2F07%2Fjavascript-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[学习js时候的一些简单的纪录，用js实现显示当前系统时间 详细代码如下 js实现123456789101112131415161718setInterval(function ()&#123; var date = new Date(); var now = "现在时间是： "; now += date.getFullYear() + " 年 "; now += (date.getMonth()+1)+ " 月 "; now += date.getDate() + " 日 "; now += date.getHours() + " 时 "; now += date.getMinutes() + " 分 "; now += date.getSeconds() + " 秒 "; var week = new Array("日", "一", "二", "三", "四", "五", "六"); var weekIndex = date.getDay(); now += " 星期" + week[weekIndex]; $("#time").html(now);&#125;, 1000); html代码1&lt;div id="time"&gt;&lt;/div&gt; 结果截图 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 命令学习]]></title>
    <url>%2F2016%2F07%2Fgit-%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[下面是一些在平时学习git时经常需要用的一些命令 git stash 把当前未提交的改动「复制」到另一个地方暂存起来，待要恢复的时候执行 git stash pop git commit –amend 提交之后发现漏掉了某些文件,选择重新add后提交再次提交是不合理的，应该先add后执行git commit –amend git reset filename 意外地把一个不需要的文件也 add 了，git reset filename 把这个文件重staging area位置移除出来，并且不会丢失任何数据 git checkout filename 快速扔掉该文件所有的变更，回到没有修改之前的状态 git checkout -b xxx 创建并且checkout到一个新的分支上 忽略一个目录 git rm -r –cached dir //首先删除已经跟踪并添加过的目录echo dir/ &gt;&gt; .gitignore //添加忽略文件，并向忽略文件中添加需要忽略的目录git add .gitignore //让git跟踪忽略文件git commit -m ‘ignore dir forever’ //提交忽略文件 git diff a b 原文链接 (1). git diff (不加任何参数) 此命令比较的是工作目录(Working tree)和暂存区域快照(index)之间的差异也就是修改之后还没有暂存起来的变化内容。(2). git diff SHA1 SHA2比较两个历史版本之间的差异 未完待续，后续使用到 git 其他相关都会慢慢积累到这里 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static和extern，定义和声明]]></title>
    <url>%2F2016%2F07%2Fstatic%E5%92%8Cextern%EF%BC%8C%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[总结一下关于声明和定义的区别，以及static和extern的异同 声明和定义 1,广义角度声明包含定义，定义是声明的一个特例。2,定义是会简历存储空间的，而声明则不会，int a;声明a的同时，也定义了a，建立了存储空间；extern b;只是声明了b，并不是定义b，表示b是在其它文件中定义的。 static和externstatic 名称 存储位置 作用范围 赋值 全局变量 静态存储区 从定义位置到文件结束，且能够被其它文件引用。 若被赋值则为赋值若没有则为0或空 静态全局变量 静态存储区 从定义位置到文件结束，且不能够被其它文件引用，限定于定义的文件内。 若被赋值则为赋值若没有则为0或空 局部变量 非静态存储区 从定义位置到函数执行结束。 若被赋值则为赋值若没有则为随机数 静态局部变量 静态存储区 从定义位置到文件结束。 若被赋值则为赋值若没有则为0或空且只被赋值一次，以后再用到还是上次的值 静态函数 栈区 定义所在文件内。 - 非静态函数 栈区 可以被出定义所在文件外的其它文件调用。 - externextern 只在头文件中声明static 只在源文件中定义 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言编译过程]]></title>
    <url>%2F2016%2F07%2FC%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[大致分为如下几个过程，编译预处理阶段，编译阶段， 汇编阶段， 链接。详细过程如下 1，编译预处理（gcc -E main.c -o main.i） 文件包含复制 将源文件中一”#include”格式包含的文件复制到编译的源文件中 宏定义替换 用实际的值替换用”#define”定义的字符串 __DATE__:当前源程序的创建日期。__FILE__:当前源程序的文件名称(包括盘符和路径)。__LINE__:当前被编译代码的行号。__STDC__:返回编译器是否位标准C,若其值为1表示符合标准C，否则不是标准C.__TIME__:当前源程序的创建时间。 决定编译代码 根据”#if”条件决定需要编译的实际代码 删除注释 行注释和块注释 2，编译（gcc -S main.i -o main.s） 对预处理过后的文件进行一系列的词法分析，语法分析，语义分析以及进行相关的优化，生成相应的汇编代码文件 3，汇编（gcc -c main.c -o main.o） 将编译过的汇编代码翻译成目标机器指令的过程 4，链接（ld） 将不同部分的代码和数据收集和组合成为一个单一文件的过程，将相关目标指令文件链接，使其成为一个整体可以被OS执行 连接器ld将各个目标文件组装在一起，解决符号依赖，库依赖关系，并生成可执行文件 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C程序在内存中的布局]]></title>
    <url>%2F2016%2F07%2FC%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[C程序在内存中的布局大致如下图所示 从上到下依次是栈空间，堆空间，bbs段，data段，文本段 栈（stack）1，地址空间由高向低减少，先分配高地址。2，由编译器自动分配释放，主要存放函数参数，局部变量的值。3，C语言函数参数进栈的顺序是从右向左（主要是为了支持可变长参数形式）。 堆（head）1，主要用于动态分配内存，malloc等函数，由free释放。 静态存储区包括bbs段和data段bbs（bbs）1，存放一些未初始化的全局变量。 data（data）1，存放一些已经初始化的全局变量，静态变量和常量。 text（text）1，存放程序执行代码的区域，区域大小在运行的时候就已经确定了。2，内存区域只读的，也可能包含一些只读的常数变量，字符串常量等。 一个非常清晰的程序图123456789101112131415161718//main.cint a = 0;//全局初始化区char *p1;//全局未初始化区int main()&#123; static int c = 0;//全局（静态）初始化区 int b;//栈区 char s1[] = "abc";//"abc\0"在常量区，s1栈区 char s2[] = "abc";//"abc\0"在常量区，s2栈区//s1和s2是不想等的 char *p2;//栈区 char *p3 = "123456";//"123456\0"在常量区，p3在栈区 char *p4 = "123456";//"123456\0"在常量区，p4在栈区//p3和p4是一样的，都只想同一个位置"123456\0"所在位置 p1 = (char *)malloc(10); p2 = (char *)malloc(20);//分配得来的10和20字节的区域在堆区 return 0;&#125; 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在TP框架下使用AJAX验证登陆后台]]></title>
    <url>%2F2016%2F07%2F%E5%9C%A8TP%E6%A1%86%E6%9E%B6%E4%B8%8B%E4%BD%BF%E7%94%A8AJAX%E9%AA%8C%E8%AF%81%E7%99%BB%E9%99%86%E5%90%8E%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[在TP框架下使用AJAX验证登陆后台 主要分为前台页面，js，后台php的实现，代码如下 前台页面1234567891011&lt;script type="text/javascript"&gt;var handleUrl = '&#123;:U("Home/Login/handle", "", "")&#125;';&lt;/script&gt;&lt;form id="login"&gt;&lt;table align="center"&gt;&lt;tr&gt; &lt;th&gt;帐号:&lt;/th&gt;&lt;td&gt;&lt;input type="username" name="username"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;密码:&lt;/th&gt;&lt;td&gt;&lt;input type="password" name="password"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;验证码:&lt;/th&gt;&lt;td&gt;&lt;input type="code" name="code"/&gt; &lt;img src="&#123;:U('Home/Login/verify', '', '')&#125;" id="code" onclick="javascript:change_code()" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;&lt;input type="reset" class='reset' value="重置" /&gt;&lt;/th&gt; &lt;td&gt; &lt;input type="submit" class="submit" value="登录"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2" &gt;&lt;div id="errM"&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/form&gt; JS12345678910111213141516$(function()&#123; var username = $(&quot;input[name=&apos;username&apos;]&quot;); var password = $(&quot;input[name=&apos;password&apos;]&quot;); var code = $(&quot;input[name=&apos;code&apos;]&quot;); $(&quot;input[type=&apos;submit&apos;]&quot;).click(function()&#123; event.preventDefault();//取消默认提交表单 $.post( handleUrl, &#123;username:username.val(), password:password.val(), code:code.val()&#125;, function(data)&#123; if(data.status == 1)&#123; window.location.href = data.url; &#125; $(&quot;#errM&quot;).html(data.info); &#125;, &quot;json&quot;);&#125;)&#125;) TP后台实现123456789101112131415161718192021222324252627282930313233343536373839public function handle()&#123; if(!IS_AJAX) $this-&gt;error(&quot;页面不存在。。。&quot;); $code = I(&apos;code&apos;); $username = I(&apos;username&apos;); $pwd = I(&apos;password&apos;, &apos;&apos;, &apos;md5&apos;); $data = array(); if ( !$this-&gt;checkCode($code) ) &#123; //检查验证码是否正确 $data[&apos;info&apos;] = &quot;验证码错误,请检查重试。。。&quot;; $data[&apos;status&apos;] = 0; $data[&apos;url&apos;] = U(&apos;index&apos;); &#125; else &#123; //验证码正确 $arrUser[&apos;username&apos;] = $username; $User = M(&apos;user&apos;)-&gt;where($arrUser)-&gt;find(); if( !$User ) &#123; //检查用户是否存在 $data[&apos;info&apos;] = &quot;用户不存在，请检查重试。。。&quot;; $data[&apos;status&apos;] = 0; $data[&apos;url&apos;] = U(&apos;index&apos;); &#125; else &#123; //用户存在检查密码是否正确 if( $pwd != $User[&apos;password&apos;]) &#123; $data[&apos;info&apos;] = &quot;密码错误，请检查重试。。。&quot;; $data[&apos;status&apos;] = 0; $data[&apos;url&apos;] = U(&apos;index&apos;); &#125; else &#123; //登陆通过，把相关内容写入session session(&apos;uid&apos;, $User[&apos;userid&apos;]); session(&apos;username&apos;, $User[&apos;username&apos;]); session(&apos;role&apos;, $User[&apos;role&apos;]); $data[&apos;info&apos;] = &quot;登陆成功,正在跳转。。。&quot;; $data[&apos;status&apos;] = 1; $data[&apos;url&apos;] = U(&apos;Home/Index/index&apos;); &#125; &#125; &#125; $this-&gt;ajaxReturn($data, &apos;json&apos;);&#125; 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ThinkPHP</tag>
        <tag>Jquery</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FIRST]]></title>
    <url>%2F2016%2F06%2FFIRST%2F</url>
    <content type="text"><![CDATA[我的第一个私人博客，之前也一直想要有一个私人的博客，想租个vps和域名，可是没有money，自己维护也很麻烦就一直搁置了。 最近借助github平台和hexo工具实现了这个小小的愿望，终于有了一个自己的blog，哈哈哈。。。 下面是大致的安装过程。 大致过程如下 github 首先在github上创建自己的账号，然后创建一个以自己名字命名的仓库，可以自己搜索怎么建立。 安装hexo 首先安装node.js，因为hexo是基于node.js开发的一个静态博客框架 安装hexo，安装的过程中可能需要更换npm源 1npm install hexo -g 初始化自己的blog 创建一个文件夹作为自己以后blog的根目录 进入该blog目录，进行初始化配置 配置根目录下的__config.yml文件 123456789mkdir blogcd bloghexo inithexo installhexo new "newAticle" //创建新的文章，执行完之后会在sources/_post/目录下会有newAticle.md文件，打开进行编辑hexo clean //清除本地缓存hexo generate //生成网站hexo serve //开启本地服务，可以在http://localhost:4000/中进行本地预览hexo deploy //部署到github上 以后每次添加新文章就按照 / hexo clean / hexo new “” / hexo generate / hexo deploy / 的顺序就可以添加新文章 选择hexo主题，next 安装next主题 启用next主题,根目录下配置文件_config.yml配置theme: next 优化配置next主题,在next主题文件目录下的配置文件_config.yml 1git clone https://github.com/iissnan/hexo-theme-next themes/next 如有疑问欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
